<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[当 MVVM 邂逅 RxSwift]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%BD%93%20MVVM%20%E9%82%82%E9%80%85%20RxSwift%2F</url>
    <content type="text"><![CDATA[MVVM 起源于2005年，由微软的架构师 John Gossman 提出的一种架构模式，并在 WPF 和 Silverlight 中使用。它是 MVC 的一种衍生架构，通过“绑定”机制将 Controller 中的业务代码脱离出来，从而促进了 UI 层与逻辑代码的分离。 RxSwift 是 ReactiveX 的 Swift 版本，扩展了观察者模式，是一套基于异步事件的响应式编程框架。 这两个神奇的技术碰撞到一起会有什么样的火花呢？下面，我将从以下几方面来简述我在使用它们时的一些感悟（纯属个人理解）：MVC、MVVM、RxSwift、MVVM邂逅RxSwift MVCMVC 可以说是一套最经典的客户端开发架构，同时苹果官方也是极力推崇的架构模式。它将项目分为：Model、View、Controller 三个层级，它们的关系如下图所示： 上图清晰的展示的它们三者的关系，Model 代表数据，View 带边视图，Controller 则负责帮助它们建立关系： Model：指模型，数据的抽象，表示业务规则； View：用户界面，展示模型返回的数据，接受并传递用户交互； Controller：响应用户交互，并映射为用户行为，从而修改模型数据指示界面更新。 Controller ，通过 data source 和 delegate 来更新视图，通过 outlet 持有视图。View 则通过 action-target 的方式传递用户事件。同时 Controller 接收到 View 传递的事件后直接修改持有的 Model ，引发 Model 的观察者（KVO）或通知机制告知 Controller ，data source 需要工作来更改 View。 这样的工作方式看起来井井有条，实际上却很难有效得将这三者区分开来，特别是苹果还设计了 UIViewController ，这就更加难于区分 Controller 和 View 了。在我看来苹果设计的 UIViewController 只是为视图提供一个容器，也就是说 Controller 中的 view 属性应该叫做 view container 更为贴切。 另外，由于 View 和 Model 相互独立，导致了 Controller 中的业务代码会随着业务的增加而日益庞大起来，最终导致了 Massive View Controller 的出现，使 Controller 不利于维护。再加上网络层在该框架下也并没有确切的定位，也导致了网络放哪里都不合适的错觉。 提示：在服务端的开发中，javabean+jsp+servlet，能够很贴切的体现 MVC 架构思想。 MVVM由于 MVC 在实现时，不易区分各个功能模块的界线和 Controller 过于厚重等问题被暴露后，由微软架构师 John Gossman 在 MVC 的基础上优化衍生，并于2005年提出的 MVVM 则完美的解决了这一问题，促进了 UI 和业务逻辑的分离。 首先，在 MVVM 中，项目被分为了：Model、View、ViewModel 3个模块： 通过上图，可以看出，实际上新架构中的 ViewModel 抢去了原来 Controller 的部分工作，从而解决了控制器过于厚重的问题。而它们的关系如下图所示： 我们可以这样理解它的各个模块： Model：和 MVC 中的一致，依然表示对数据的抽象，体现了业务的规则； ViewModel：新架构增加的中间层，用于管理视图和模型之间的相互影响的因果关系。换句话说：模型的改变可能会影响视图对应的改变，而视图的改变也可能会引发模型作出相应的改动，最初这部分工作是由控制器来做的，现在 MVVM 中则由 ViewModel 来实现，而至于它们之间的相互影响的关系是使用 KVO 还是 Rx 只是具体的实现技术而已，与架构本身并没有关系； View：将模型返回的数据用最高可读性的方式表达给用户，响应并传递用户交互； 我认为这三个模块并不完整，因为项目中有众多的 View 和 ViewModel ，然而它们的关系需要 Controller 来建立，也就是“绑定”，所以还应该补充一点： Controller：完成 View、ViewMode 二者的关系建立。 经过这样的演进，最终大量的逻辑代码将被移动到 ViewModel 中，从而 Controller 只需要管理视图以及视图和 ViewModel 之间的绑定关系，达到了更轻量级的控制的目的。同时，无处安放的网络请求也将由 ViewModel 实现，并提供 Command 的接口给 Controller 调用。 另外，由于 UIViewController 和 UIView 只是不同的组件而已，在苹果的实现中通常都是对应出现的，能看到 View ，那么就一定能找到一个对应的 Controller ，能出现一个 Controller ，也一定能找多至少一个 View ，所以索性就将它们两个看成一个模块，只是递进关系不同，功能存在包含而已。基于这样的考虑，我在项目结构上大致如下： 12345678910111213141516171819-------------------------| ... || || Model || || | /|\ || | | || \|/ | || || ViewModel || || | /|\ || | | || \|/ | || || View &amp; Controller || || ... |------------------------- 这是一个比较受争议的划分，只是在我看来如果非要严格的区分控制器和视图，在某种情况下会让架构失去灵活性，增加开发难度，不利于实践使用。例如：我要实现一个全局配置的功能，实际上我只需要很少量的视图组件就能完成，这个时候还非得区分 View 和 Controller，反倒没有直接将 UIViewController 即看作控制器又看作视图来的直接，而真正的业务模块的确应该坚持职责单一原则，区分得足够详细，后期维护就能够事半功倍。 我们再将视线移回到模块职业上。 MVVM 作为 MVC 的升级版，优化了随着业务的增加导致了 Controller 逐渐臃肿等问题，那么升级过后的模块又是怎么样的职业划分的呢？ 首先，模型做为数据的抽象，它体现了业务的形态，所以模型的实现一定是根据具体业务进行抽象，例如：我们有一个网上的商品交易系统，现在要做商品的买卖需求。在这个需求中，买东西一定需要定位到单一的商品，买家和卖家也一定要形成唯一关系，从而我们在设计 order 模型时，一定就需要有字段能够接受商品的唯一id，卖家的唯一id和买家的唯一id，这样一来，谁要买谁的什么商品的需求就抽象成 order 的模型来体现了！ 所以在我看来，如果模型所做的事情超出了了业务形态的范围，那么就不算是一个优秀的设计。当然，作为数据的载体，它也应该提供相应的数据读写接口，供其他模块调用。（这也是我认为“胖 model”不合理的原因） 接下来再来看看重头戏：ViewModel。作为 Controller 的小弟，它帮助控制完成了大量的工作，那么那些工作应该由它来做呢？我归纳了以下几点（可能有点片面）： 使用抽象模型作为载体修改和更新数据。数据作为系统核心价值的体现，用户通过点击、拖拽等操作 View ，通过 ViewModel 来控制模型进而修改数据，一方面这样能够降低核心数据被恶意窜改的风险，另外，对开发者而言，这样的设计能够提高代码的可维护性； 作为 View 和 Model 之间的桥梁，那么视图的显示逻辑部分应该由 ViewModel 来完成； 应该具备或持有 Model ，进而能够修改 Model 所代表的数据； 提供输入和输出接口，方便 Controller 进行绑定调用； 实现网络请求，并将结果序列化为对应模型。 其他… 以上的小点是我在使用中真实所使用到的场景，可能不全面，等遇到的时候再添加吧。 最后，Controller 作为控制器，应该管理视图容器（也就是自己的 view）的生命周期，生成子视图并放入到视图容器中一并管理，将 ViewModel 进行绑定完成特定的业务场景。 RxSwift上面我们有讲到实现 MVVM 无论采用 KVO 还是 Rx 都只是实现的技术不同而已，与架构本身没有关系。就 Rx 而言，它本身是一套基于异步事件的响应式框架而已。只是它让 MVVM 的实现更加优美，所以当提到 MVVM 的时候，首先想到的正是 Rx。起初在 RAC 还没有开发出来的时候，MVVM并不是如此火热（至少在 iOS 上是这样的），应该说是 RAC 奠定了 MVVM 的崛起。 Rx 是 ReactiveX 的缩写，而 ReactiveX 一个基于异步事件的响应式库。它基于观察者模式，支持异步数据和事件序列，通过简单的运算符就能实现对这些序列的订阅、组合、转换等，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。并且它还是一套跨平台的响应式标准，可以到达一处学会到处使用。 了解了 Rx 是什么之后，我们来了解下它作用是什么（至少在 iOS 中）？下面我们通过具体场景来看看它充当了什么角色： (1). 登陆界面中，我们有一个电话号的输入框，要求输入框需要验证电话号是否正确； 如果我们使用原始技术实现的话，我们可能会使用这几种事件传递的方法处理：delegate、notifinotion、target-action、KVO 等等； 而 Rx 则统一这些传递方法为信号传递，我们只需要将上面提到的方法全部替换为 rx 所代表的信号链就能完成相同的工作。 下面是一个简单示例，仅供参考： 123456789101112131415161718192021222324252627#program mark - 原始技术textField.addTarget(self, action: #selector(textField(didEditingChanged:)), for: .editingChanged)@objcfunc textField(didEditingChanged sender: UITextField) &#123; var text = sender.text if text.valid(type: .phone) &#123; // 这里实现通过电话验证的逻辑 &#125; else &#123; // 这里实现未通过电话验证的逻辑 &#125; // 最终逻辑&#125; #program mark - RxSwifttextField.rx.text.orEmpty .map &#123; // 实现电话号验证的逻辑 $0.valid(.phone) &#125; .subscribe &#123; // 最终逻辑 &#125; .disposed(by: disposeBag) (2). 在 MVVM 中，为数据绑定提供了更加方便及优美的实现方案。 当然，它的作用远不止于此，只是就本文的主题而言，我认为这两点已经足够了。 Observables 可以算是 Rx 的核心了，正是它让我们可以对任意异步事件柳进行随意的组合。例如：使用它来作为网络请求的返回值，那么我们从代码的阅读性上就可以看作是一次同步过的过程了，而处理回调只需要订阅它对应的事件即可： 123456789101112131415161718192021222324252627func resume() -&gt; Observable&lt;T&gt; &#123; return Observable&lt;T&gt;.create &#123; observer -&gt; Disposable in let request = Alamofire.request(self.url, method: self.method, parameters: self.parameters, encoding: self.encoding, headers: self.headers) .responseData &#123; if let error = $0.error &#123; observer.onError(error) &#125; else &#123; if let data = $0.data &#123; do &#123; observer.onNext(try JSONDecoder().decode(T.self, from: data)) observer.onCompleted() &#125; catch &#123; observer.onError(error) &#125; &#125; &#125; &#125; return Disposables.create &#123; request.cancel() &#125; &#125;&#125; 经过这样封装后的网络请求更像是同步的操作，因为发送后立即就能得到一个可观察的返回值，而我们只需要监听返回值的相应事件即可，一定程度上简化了异步的思想。 当然，以上两点只是 Rx 的一些应用而已，它的功能其实远不止于此，更多的内容还有待继续探究。 其实函数式编程和响应式编程还是有很大区别的，官方文档中式这样描述的： One main point of difference is that functional reactive programming operates on values that change continuously over time, while ReactiveX operates on discrete values that are emitted over time. 在这里我们就不具体讨论这两者的区别。 MVVM邂逅RxSwift通过上面的三个小章节，我们一起了解了 MVC ，MVVM 以及 RxSwift 。这章节中，我将以“登录”模块作为示例，简示 MVVM 和 RxSwift 会碰撞出什么样的火花。 需求：登录界面中需要填入用户名和密码“登录”按钮才能点击，点击后进行网络请求，成功提示“登录成功”，失败提示具体原因。 在实现 UI 时，我为了更好的区分 Controller 和 View，我将用户名输入框、密码输入框以及按钮放在了单独的 SignContentScrollView 中，并将这三个空间作为公用接口暴露出来，代码如下： 12345678910111213class SignContentScrollView: UIScrollView &#123; private weak var panguLogoImageView: UIImageView! private weak var titleLabel: UILabel! private weak var inputContainer: UIView! weak var usernameTextField: UITextField! weak var passwordTextField: UITextField! weak var signButton: UIButton! weak var forgetButton: UIButton! ...&#125; View 层算是解决了，接下来看看 ViewModel 应该如何设计？ ViewModel 作为视图和模型的桥梁，它不仅能够修改或获取模型，还能够响应用户交互和跟新用户界面，我更倾向于将它理解为一座“工厂”，用户界面给它提供“原材料”，经过加工后输出形成可直接使用的产品，这里的加工就是具体的业务逻辑了。结合 Swift 面向协议的特点，可以抽象一个 ViewModelType 的协议： 1234567891011121314151617181920212223242526272829303132fileprivate struct ViewModelTypeAssociateKey &#123; static var disposeBag: String = &quot;disposeBag&quot;&#125;protocol ViewModelType &#123; associatedtype Inputs associatedtype Outputs // 用于管理 Observable 的释放，通过协议的扩展直接给予默认值 var disposeBag: DisposeBag &#123; get &#125; var inputs: Inputs &#123; get &#125; var outputs: Outputs &#123; get &#125; &#125;extension ViewModelType &#123; var disposeBag: DisposeBag &#123; get &#123; guard let bag = (objc_getAssociatedObject(self, &amp;ViewModelTypeAssociateKey.disposeBag) as? DisposeBag) else &#123; let bag = DisposeBag() objc_setAssociatedObject(self, &amp;ViewModelTypeProtocolAssociateKey.disposeBag, bag, .OBJC_ASSOCIATION_RETAIN) return bag &#125; return bag &#125; &#125; &#125; 这样我们就有了一个协议来实现对所有 ViewModel 的公共抽象。它具有一个输入和一个输出的结构体，结构体中都会使用 Rx 的 Observable 的对象组成，通过对 Observable 订阅可以实现随时的监听。当落实到具体的登录业务时，ViewModelType 就可以这样实现了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class SignViewModel: ViewModelType &#123; struct Inputs &#123; let username: AnyObserver&lt;String&gt; let password: AnyObserver&lt;String&gt; let signCommand: AnyObserver&lt;Void&gt; &#125; struct Outputs &#123; let validSignSignal: Observable&lt;Bool&gt; let signStatusSignal: Observable&lt;RequestStatus&gt; &#125; var inputs: Inputs var outputs: Outputs private let usernameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) private let passwordSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) private let signCommandSubject = PublishSubject&lt;Void&gt;() private let signStatusSubject = PublishSubject&lt;RequestStatus&gt;() private var loginByNameApi: String &#123; get &#123; let paths = &quot;/&quot;+kSSODirectionPath+&quot;/&quot;+kLoginByNameApi guard let api = BaseURLModel.default.SSOApi else &#123; return paths &#125; return api+paths &#125; &#125; private var username: String = &quot;&quot; private var passowrd: String = &quot;&quot; init() &#123; inputs = Inputs(username: usernameSubject.asObserver(), password: passwordSubject.asObserver(), signCommand: signCommandSubject.asObserver()) outputs = Outputs(validSignSignal: Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125;, signStatusSignal: signStatusSubject) usernameSubject.asObserver() .bind(to: self.usernameBinder) .disposed(by: disposeBag) passwordSubject.asObserver() .bind(to: self.passwordBinder) .disposed(by: disposeBag) signCommandSubject .subscribe(onNext: &#123; [unowned self] in self._respondsToSignIn() &#125;) .disposed(by: disposeBag) &#125; private func _respondsToSignIn() &#123; self.signStatusSubject.onNext(.doing) YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi) .method(.post) .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;]) .resume() .subscribe(onNext: &#123; (response) in if response.code == 200 &#123; self.signStatusSubject.onNext(.success) &#125; else &#123; self.signStatusSubject.onNext(.failed(message: response.msg)) &#125; &#125;, onError: &#123; (error) in self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;)) &#125;) .disposed(by: self.disposeBag) &#125; &#125;extension SignViewModel &#123; private var usernameBinder: Binder&lt;String&gt; &#123; return Binder(self) &#123; $0.username = $1 &#125; &#125; private var passwordBinder: Binder&lt;String&gt; &#123; return Binder(self) &#123; $0.passowrd = $1 &#125; &#125; &#125; usernameSubject、passwordSubject、signCommandSubject 作为 inputs 的桥梁来链接外部参数和内部业务，可以让我们不需要通过方法将 input 和 output 进行转化，Controller 中只需要将输入信号和 inputs 中对应的信号绑定，内部就能通过桥梁信号监听相应的变化。 在 extension 中，通过数据绑定，将 usernameSubject 和 passwordSubject 的改变值绑定至 username 和 password 中，就是用户的交互改变数据模型的操作，网络请求时就能直接使用正确的值作为参数进行传递，绑定代码如下： 1234567usernameSubject.asObserver() .bind(to: self.usernameBinder) .disposed(by: disposeBag) passwordSubject.asObserver() .bind(to: self.passwordBinder) .disposed(by: disposeBag) 登录按钮的验证通过对 usernameSubject、passwordSubject 的组合，验证用户名和密码是否合规，最终转化为 Observable&lt;Bool&gt; 的对象，供按钮的 isEnable 直接绑定： 1Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125; 登录的状态也通过 let signStatusSignal: Observable&lt;RequestStatus&gt; 提供外部接口，直接观察状态的改变实现成功或失败的提示。（注：我认为 Controller 做页面的跳转和各种弹窗是必要的工作，所以我将这些放在控制器中做。） 最后，当按钮点击后，通过 signCommand 将按钮点击事件传递进来，内部通过订阅取得对应事件并发送网络请求： 1234567891011121314151617private func _respondsToSignIn() &#123; self.signStatusSubject.onNext(.doing) YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi) .method(.post) .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;]) .resume() .subscribe(onNext: &#123; (response) in if response.code == 200 &#123; self.signStatusSubject.onNext(.success) &#125; else &#123; self.signStatusSubject.onNext(.failed(message: response.msg)) &#125; &#125;, onError: &#123; (error) in self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;)) &#125;) .disposed(by: self.disposeBag)&#125; 这里我提一句，得益于 Swift 的范型特点，我们做网络请求时可以取得准确的数据模型。 由于 Swift 是一门数据严谨的语言，所以在模型设计上就不会想 Objective-C 一样那么灵活了。这里我通过示例简单的展示下我遇到的坑，及解决办法： 12345678910typealias ModelType = Codable &amp; DescriptionDebugablestruct BaseModel&lt;T: ModelType&gt;: ModelType &#123; var code: Int var msg: String var success: Bool var data: DataWithStringType&lt;T&gt;! var progressTask: ProgressTask? var errors: [ErrorModel]?&#125; 很明显，我所在的项目中 data 字段是所有的有用字段的集合。坑就在这里，当请求正确无误时，data 字段是正确的数据结构，而当请求错误时，服务端将 data 字段设置为一个字符串了，而在 Swift 中，数据类型是唯一确定的，我们不能将 data 字段即设置为一个数据结构又设置为一个字符串。而解决办法就是 – 转化，所以增加了一个 DataWithStringType 的模型，用于判断当前值是否为结构体，如果是，那么就归档到 entity 中，否则就归档到 string 中： 12345678910111213141516struct DataWithStringType&lt;T: ModelType&gt;: ModelType &#123; var string: String? var entity: T? init(from decoder: Decoder) throws &#123; let singleValueContainer = try decoder.singleValueContainer() if let stringValue = try? singleValueContainer.decode(String.self) &#123; string = stringValue &#125; else if let entityValue = try? singleValueContainer.decode(T.self) &#123; entity = entityValue &#125; &#125; &#125; 当所有的准备工作完成后，来看看 Controller 是如何将 ViewModel 和 View 绑定的： 12345678910111213141516171819202122232425262728293031func bindingViewModel() &#123; scrollView.usernameTextField.rx.text.orEmpty .bind(to: signVm.inputs.username) .disposed(by: signVm.disposeBag) scrollView.passwordTextField.rx.text.orEmpty .bind(to: signVm.inputs.password) .disposed(by: signVm.disposeBag) scrollView.signButton.rx.tap .bind(to: signVm.inputs.signCommand) .disposed(by: signVm.disposeBag) signVm.outputs.validSignSignal .bind(to: scrollView.signButton.rx.isEnabled) .disposed(by: signVm.disposeBag) signVm.outputs.signStatusSignal .subscribe &#123; [unowned self] in self.view.endEditing(false) switch $0.element! &#123; case .doing: self.view.makeActivityWithText(&quot;正在登陆&quot;, userInteraction: false) case .success: self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activitysuccess&quot;), text: &quot;登陆成功&quot;) case let .failed(message): self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activityerror&quot;), text: message) &#125; &#125; .disposed(by: signVm.disposeBag)&#125; 这样整体看起来，代码的模块性十分的良好。vm 甚至可以单独拿出来进行测试。当内部的业务逻辑需要更改时，几乎可以只动 vm 中的代码就能实现变更。并且在响应上，由于是绑定关系，那么逻辑链路还是相对明显的。举个例子： 123scrollView.passwordTextField.rx.text.orEmpty .bind(to: signVm.inputs.password) .disposed(by: signVm.disposeBag) 将密码的输入绑定到 vm 的 username，而该对象通过 passwordSubject转接到 vm 中执行相应业务逻辑。 小结在这篇文章中，通过在真实的项目中使用 Rx 和 MVVM 实现“登录”的需求来学习这二者。我认为重点是对于 vm 的设计和 Controller 如何进行数据绑定的。另外，至于 MVVM 中每个模块应该干什么，还是任重道远啊。 博文推荐： 深入理解MVC iOS 关于MVC和MVVM设计模式的那些事 iOS应用架构谈 view层的组织和调用方案 MVVM 介绍 RxSwift + MVVM: how to feed ViewModels]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从 WWDC 2018 220 Session 窥探 Auto Layout]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BB%8E%20WWDC%202018%20220%20Session%20%E7%AA%A5%E6%8E%A2%20Auto%20Layout%2F</url>
    <content type="text"><![CDATA[苹果公司早在 iOS 6 系统中就引入了 Auto Layout ，到目前为止，开发人员进行界面布局大致可以分为两类： Frame 、 Auto Layout 。使用 Frame 进行布局的开发者认为，这种方式更精确，并且性能优良，然而该方式过于原始，一方面在界面维护性差（杠精可能不这么觉得），另一方面在多屏幕适配上让人头疼。使用 Auto Layout 的开发者则认为，该方式在屏幕适配上占尽优势，在加入 了Interface Builder 后更是将“所见即所得”体现得淋漓尽致，但是最终形成视图显示时任然还是落实到 origin 和 size 上，从而中间会多出大量的根据约束、优先级等计算位置和大小的操作，一定程度上降低了性能，而且使用不当还极易造成崩溃。 在 High Performance Auto Layout 中介绍说：苹果公司在 iOS 12 中大幅提高了Auto Layout的性能，使滑动达到了满帧。为了更清楚解释 Auto Layout ，我们将从以下几点进行探讨：运行过程 、自动布局的性能问题、自动布局的方案 运行过程Auto Layout 布局系统不仅仅是实现了 Cassowary) 算法来解决用户界面中哪些相等和不等的关系，引入了“约束”的概念来抽象界面关系。它还是一套完整的布局引擎系统，用来统一管理布局的创建、更新和销毁，它主导了整个界面的布局。 首先，来看看自动布局的渲染过程。 苹果将一个渲染循环分为了3个步骤：更新约束、布局和显示： 所有需要的视图会根据层级关系从顶至低依次调用updateConstraints来更新约束； 接着，每个视图都会g根据层级关系沿着从低至顶的顺序依次执行layoutSubviews来进行布局； 最终，获取到布局信息后，视图和布局一样的执行方式调用drawRect进行绘制，从而将内容显示在用户的屏幕上。 于是，基于此流程，苹果开放了一套 API 给开发者使用，目的就是避免大量的重复工作，导致性能的损失： setNeedsUpdateConstraints，将 view 标记为需要更新约束，并在稍后触发updateConstraitsIfNeed; updateConstraitsIfNeeded，系统自动调用该方法。但是只有被第1点标记了的 view 才会调用updateConstraints。该方法，开发者可以手动调用，但不需要重写。 updateConstraints，更新约束的方法。 setNeedsLayout，将 view 标记为需要重新布局，并在稍后自动触发layoutIfNeeded。当 view 的布局发生改变时，也会自动调用。 layoutIfNeeded，系统自动调用该方法。同样，只有被第4点标记的 view 才会调用layoutSubviews。该方法，开发者可以手动调用，但也不需要重写。 layoutSubViews，不能手动调用。 setNeedsDisplay，将视图标记为需要重新绘制，并且触发绘制循环执行drawRect。 drawRect，视图的绘制，不能手动调用。 现在我们已经知道了 view 根据 Auto Layout 的绘制流程了，并且对苹果提供的 API 有了更为清晰的理解。 最后，我们再来聊聊布局引擎（以下简称：Engine）在渲染过程中起到的作用： 在自动布局框架中，布局的计算核心是 Engine ，换句话说，我们从添加的约束到获取到 view 的大小和位置信息都是由 Engine 进行计算的。我们说 Auto Layout 实现了 Cassowary 算法，主导了界面的布局，更精确的说是 Engine 来完成。 当然，光从上图很难看出 Engine 在渲染过程中起到的作用，我们结合 WWDC 进行理解。下面是一段原话： When the constraint is added what will happen is that we make an equation, which corresponds to the constraints, and we add that equation to the engine. The last object to understand in the diagram is that the equation is in terms of variables where a variable is like, you know, if I hand you an equation and I say solve for X, X is a variable. The things that we need to solve for in this case is the frame data of a view. So there will be four variables for every view, which is the min X, the min Y, the width, and the height. 当我们给 view 添加约束（以下称：NSLayoutConstraint）时， Cocoa 会根据 NSLayoutConstraint 创建一个 Equation 的等式添加到 Engine 中，Engine 拿到等式后，依据 Cassowary 算法对 NSLayoutConstraint 中约定的变量（以下称：Variable）进行求解。求得结果后 view 通过 layoutSubviews 将 Engine 中的 Frame 拷贝出来，以供显示绘制使用。我们来看看代码是如何转化为 Equation 的： 1234567[NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:view2 attribute:NSLayoutAttributeLeft multiplier:1 constant:10] Equation =&gt; 1view1.left = view2.left * 1 + 10 其中 view1.left 就是 NSLayoutConstraint 设置的 Variable ，需要 Engine 进行求解。 经过这样的理解，我将我的理解绘制成这样一幅简图： 上图中，我将 Engine 的工作这样理解：每个 view 在显示自己之前即得到布局信息之前， Engine 会将视图、约束、优先级和固定大小通过计算转换成最终的 Frame ，在 Engine 中，每当约束发生变化就会触发名叫：Deffered Layout Pass 的容错处理，当这些工作完成后，视图的绘制也会随之一并完成。为了继续监听约束变化，渲染循环（ps：其实这里渲染循环和运行循环是否是同一个东西，查了很多资料也没说个所以然，但是不影响对 Auto Layout 的理解。所以先暂时叫 Application Run Loop 统一名称。）又进入监听约束变化的状态，等待下次响应。当监听到约束变化后，再次执行下一轮循环。 这里有相关的参考链接： Changing Constraints 自动布局的性能问题上面我们对 Auto Layout 的运行过程进行了探讨。不难看出相对于 Frame 布局而言， Auto Layout 多出了对约束的更新、计算等操作，肯定会对效率产生一定的影响。然而这些影响如果在一次 Display 所允许的时间范围之内完成（60次/s），那么无论对开发者还是用户而言，都是可以接受的。在这章，我们一起来探讨影响 Auto Layout 性能的因素，从根儿上去理解这些问题，对我们将来开发工程中的取舍会有一定的帮助。 上图是来 What’s New in Cocoa Touch 数据，从上图可以看出，无论是嵌套还是非嵌套的视图层级关系而言，在 iOS 12 优化了 Auto Layout 之后，基本上和手动布局一致，都不会因为视图数量或嵌套层数的增加而导致性能的损耗成指数上升。那么导致优化前，性能成指数损耗的锅就应该由 Cassowary 来背吗？ Cassowary is an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities. 就 Cassowary 算法本身而言，是1997年就被发表并被称作高效的线性方程求解的算法，解决的是界面的线性规划问题，而线性规划问题的解法是单纯型法–Simplex。单从 Simplex 算法看，大多数情况下是没有呈指数时间复杂度的。而 Cassowary 是在 Simplex 的基础上，为解决用户界面实践中的应用和改进算法，最重要的是提出了“增量”的概念。从这个维度上来看， Cassowary 不能背这口黑锅。 那么，如果 Cassowary 算法本身是没有问题的话，那就只可能是 iOS 12 之前在实现算法时，并没有体现出增量的概念。 在 WWDC 2018 220 Session 中提到，系统从 Engine 中获取 view 的大小可分为以下几步： 创建一个 Engine 对象； 约束被添加到 Engine 中； Engine 计算出所有的布局信息； view 从 Engine 中拷贝出布局信息； Engine 对象呗销毁。 咋眼一看似乎没有什么问题，但是如果每次细微的更新约束都需要从0开始，新的计算引擎对象都要重新计算，当约束变关系变多时，最终会导致计算量的指数上升。 显然苹果早就注意到这个问题，在 iOS 12 中找到了并实现了解法。当然，性能是否真的如视频所说？这里有一篇文章，对 Auto Layout 进行了比较深入的测试：点击查看。 综上所述，尽管苹果一直在对 Auto Layout 进行优化升级，但目前为止，任然不如 Frame 布局来的直接、有效，然而这只是在相对极端的情况下才会出现，通常我们遇到的开发需求中是不会出现这种情况的。最终我们可以粗暴的认为： Auto Layout 具有了和手写布局几乎一致的高性能。 自动布局的方案除了上面探讨的 Auto Layout 性能问题之外， Auto Layout 框架的易用性也是影响其使用的关键因素之一。苹果公司自然比我们更清楚这一点的重要性。所以，后来又提供 VFL 这种 DSL 语言来简化 Auto Layout 的写法。再到后来，苹果紧随前端响应式布局– Flexbox 的思路，基于 Auto Layout 封装了 UIStackView 来提高响应式布局的开发效率。当然，这里我们不去着重探讨上述的布局方案，而是简单阐述以下几种 Auto Layout 方案的优缺点，以供大家选择： NSLayoutConstraint 实现 Auto Layout 上述我们提到了苹果使用 NSLayoutConstraint 来体现了 Cassowary 的约束的概念，并且苹果在 Auto Layout 框架中也只提供了它所对应的一套 API 供开发者使用，也就是说任何基于自动布局技术的其他方案都必然会通过 NSLayoutConstraint 来实现。 从上面的代码中，可以看出 NSLayoutConstraint 的可阅读性还是很好的，然而对开发过程中，多如牛毛的约束，显然这种方式是不可取得，太影响开发效率了。 苹果自家的可视化编辑方案：Interface Builder 我认为 Interface Builder 是一个革命性的突破。在没有它之前，我们的所有控件都必须通过代码初始化，设置 frame ，设置各种属性，然后 addSubview 到父视图上。这部分工作重复且毫无意义，直到 IB 的出现，它让 iOS 开发工程能够更容易的构建 App 的视图，并且更直观的进行视图编辑，只是简单的通过点击选择、拖拽等操作就可完成，最后通过 IBOutlet 将 IB 中的控件连接到代码中，供开发者直接使用。更多的时间都投入到业务开发中去，大大的提高了工程师的开发效率。（ps：我之前注意到，相同的需求，相同的迭代周期，相同的界面，Android由3个开发同时进行，iOS由2个开发同时开发，最终iOS完成迭代开发的时间早于Android2天，并且从高保真的还原度上而言也是得到了UI同事的赞扬的！） 难道 IB 真的就这么完美，找不出缺点吗？ 答案是否定的。 IB 在有如此高效且易用的有点下，缺点也是十分明显： IB 本质上也是一个 XML 文件，最终呈现成 view 时还是会转化成代码来完成，从而 IB 的执行效率低于手写代码； 在多团队开发中容易造成错误； 不利于代码的封装和工程架构的组织等； 学习成本相对较高。 Masonry 三方框架 你或许没有使用过 IB 进行界面开发，但是我相信 Masonry 你一定用过。它是基于 Auto Layout 的链式封装，不仅简化了 NSLayoutConstraint 带来繁杂的工作量，还更加清晰明了的解释了视图之间的约束关系。目前从我所经历的需求池看来， Masonry 都能够完成。毕竟是基于“老祖宗”的。虽然，时至今日，开发者也发现了很多它的问题，但这都是后话了，也不属于我们需要在这里探讨的话题了。 小结这篇文章是我在观看了 WWDC 2018 220和202 之后对 Auto Layout 一些感悟或者理解。我们从原理上探讨了自动布局技术的运行过程和自动布局的性能问题，并简单的提到了苹果在布局引擎中利用 Cassowary 算法进行线性规划问题的求解，对以后开发过程中遇到的问题能有更深层次的解释，自然也能更容易解决这些问题。又简单的总结了3中自动布局方案，并分别简述了各自的优缺点，希望能够为技术选型时提供一些参考。]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
</search>

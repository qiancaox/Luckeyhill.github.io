<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从 SQLite 到 FMDB，我经历了什么]]></title>
    <url>%2F2019%2F05%2F06%2F%E4%BB%8E%20SQLite%20%E5%88%B0%20FMDB%EF%BC%8C%E6%88%91%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[移动端的纯在线 App 已经跟不上时代的节奏了，或多或少都会有一些数据需要本地存储。目前在 iOS 上有以下几种方式可供选择： NSUserDefault，也称偏好设置。用于数据规模小，于业务无关的数据存储； keychain，苹果提供的带有可逆加密的存储机制，只要系统不重装，数据都能得到保留，并且支持 iClound 云同步，普遍用于各种存密码的存储和用户唯一标识串等； 文件存储： Plist 文件，也称属性列表。结构化较好或需要方便查询的数据可以选择； Archive ，也叫归档/解档。如果需要直接对象化数据时使用，但是由于归档或解档时需要对对象序列化，耗时较多； 一般文件存储，由于文件在在读写时耗时，所以通常用在量比较小的数据上。 CoreData，苹果官推的数据存储框架，笔者没使用过，这里有个文章可以看看：我为什么不喜欢 Core Data； 数据库存储。 说到数据库存储，目前流行的有： SQLite、Realm 等方式在移动端使用。并且它们都有轻量级、跨平台的特点，而今天的主角是 SQLite 数据库。下面将从两方面来探讨下：SQLite、FMDB SQLiteSQLite 是基于 C 语言实现的 SQL(结构化查询语言) 的轻量级关系型数据库的库。并且它还支持跨平台和读写速度快的特性，可以用于嵌入式和移动端的数据存储。但是，由于它没有单独的服务器进程，所以并不能够像 MySQL、Oracle、PostgreSQL 这些大型数据用于服务端的开发。 SQLite does not have a separate server process. 由于它是 C 语言的库，所以在使用过程中，通常都会进行一定的封装。让我们来看 SQLite 的简单使用。 首先，要想操作数据库，必须要初始化并打开对应的 sqlite3 对象，而且由于这个方法可能会多次调用，所以封装为公用方法： 12345678910111213141516- (BOOL)open&#123; NSString *dbPath = [self _databaseSandboxPathWithDBName:nil]; NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:dbPath] == NO) &#123; BOOL rt = [fileManager createFileAtPath:dbPath contents:nil attributes:nil]; if (!rt) &#123; return NO; &#125; &#125; int rt = sqlite3_open([dbPath fileSystemRepresentation], &amp;_database); return rt == SQLITE_OK;&#125; 在 sqlite 库中，open 方法有3个，分别为：sqlite3_open、sqlite3_open16、sqlite3_open_v2 ，其中前两个默认以可读可写的方式打开数据库，如果数据库不存在则创建一个。而第三个则提供给用户接口控制打开数据库的方式，该方式通过 flags 来控制。 与之对应的就是关闭数据库： 123456- (void)close&#123; if (_database) &#123; sqlite3_close(_database); &#125;&#125; 当数据库打开后，就可以建表了。而建表就需要执行 SQL 语句了，作为简单得封装，我们只考虑用户输入表明和字段说明的语句，而完整的语句由库拼接： 123456789101112- (BOOL)createTableWithName:(NSString *)name fileds:(NSString *)fileds&#123; NSString *sql = [NSString stringWithFormat:@&quot;create table if not exists %@ (%@)&quot;, name, fileds]; if (![self open]) &#123; return NO; &#125; char *msg = NULL; int rt = sqlite3_exec(_database, [sql UTF8String], nil, nil, &amp;msg); return rt == SQLITE_OK;&#125; 函数 sqlite3_exec 接受5个参数，比较重要的是执行语句 [sql UTF8String] 、回调（第三个）和回调函数中的首个传递值（该函数中的第四个）。回调函数将会在执行查询时每查询到一条记录执行一次。 通常，使用数据库的核心和基础就是增、删、改、查。同样，也需要进行简单的封装才能使用。 当需要向表中插入一条记录时，封装以下方法： 12345678910111213141516171819202122232425262728293031- (BOOL)insertValues:(NSDictionary *)map inTable:(NSString *)table&#123; if (![self open]) &#123; return NO; &#125; __block NSMutableArray *values = [NSMutableArray arrayWithCapacity:map.count]; __block NSMutableArray *keys = [NSMutableArray arrayWithCapacity:map.count]; [map enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; [keys addObject:key]; [values addObject:obj]; &#125;]; NSString *keysString = [keys componentsJoinedByString:@&quot;, &quot;]; for (int i = 0; i &lt; values.count; ++i) &#123; id value = values[i]; if ([value isKindOfClass:NSString.class]) &#123; [values replaceObjectAtIndex:i withObject:[NSString stringWithFormat:@&quot;&apos;%@&apos;&quot;, value]]; &#125; &#125; NSString *valuesString = [values componentsJoinedByString:@&quot;, &quot;]; NSString *sql = [NSString stringWithFormat:@&quot;insert into %@ (%@) values (%@)&quot;, table, keysString, valuesString]; char *msg = NULL; int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg); [self close]; return rt == SQLITE_OK;&#125; 外部只需要讲表格内容按照字段的方式传入，库会帮助拼接 SQL 语句。这里比较片面的是我只兼容了两种数据类型：text、integer，并且在拼接字符串时，只会给 text 加入单引号区分。 1234567891011121314- (BOOL)deleteColumnWithFactor:(NSString *)factor inTable:(NSString *)table&#123; if (![self open]) &#123; return NO; &#125; NSString *sql = [NSString stringWithFormat:@&quot;delete from %@ where (%@)&quot;, table, factor]; char *msg = NULL; int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg); [self close]; return rt == SQLITE_OK;&#125; 当需要删除表格中的行时，需要按照条件 factor 进行 where 的过滤。但是由于查询时，数据的数据类型需要进行判断，所以代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192- (NSArray *)queryColumnsWithFactor:(NSString *)factor inTable:(NSString *)table&#123; if (![self open]) &#123; return nil; &#125; NSString *sql = [NSString stringWithFormat:@&quot;select * from %@ &quot;, table]; if (factor) &#123; sql = [sql stringByAppendingString:[NSString stringWithFormat:@&quot;where (%@)&quot;, factor]]; &#125; sqlite3_stmt *stmt = NULL; int valid = sqlite3_prepare_v2(_database, [sql UTF8String], -1, &amp;stmt, NULL); if (valid == SQLITE_OK) &#123; NSMutableArray *array = [NSMutableArray arrayWithCapacity:0]; // 只有当返回值位 SQLITE_ROW 时表示有值查询出来，需要进一步解析 while (sqlite3_step(stmt) == SQLITE_ROW) &#123; int count = sqlite3_column_count(stmt); if (count &gt; 0) &#123; NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithCapacity:count]; for (int i = 0; i &lt; count; ++i) &#123; // 获取列的名字 NSString *columnName = [NSString stringWithUTF8String:sqlite3_column_name(stmt, i)]; // 获取列的数据类型，在sqlite3.h文件中的第4369行定义为： /* #define SQLITE_INTEGER 1 #define SQLITE_FLOAT 2 #define SQLITE_BLOB 4 #define SQLITE_NULL 5 #ifdef SQLITE_TEXT # undef SQLITE_TEXT #else # define SQLITE_TEXT 3 #endif #define SQLITE3_TEXT 3 */ int columnType = sqlite3_column_type(stmt, i); // 声明一个值容器 id value = nil; if (columnType == SQLITE_INTEGER) &#123; value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, i)]; &#125; else if (columnType == SQLITE_FLOAT) &#123; value = [NSNumber numberWithDouble:sqlite3_column_double(stmt, i)]; &#125; else if (columnType == SQLITE_BLOB) &#123; const char *dataBuffer = sqlite3_column_blob(stmt, i); int dataSize = sqlite3_column_bytes(stmt, i); if (dataBuffer != NULL) &#123; value = [NSData dataWithBytes:(const void *)dataBuffer length:(NSUInteger)dataSize]; &#125; &#125; else &#123; const char* c = (const char*)sqlite3_column_text(stmt, i); if (c != NULL) &#123; value = [NSString stringWithUTF8String:c]; &#125; &#125; if (value) &#123; [dic setValue:value forKey:columnName]; &#125; else &#123; [dic setValue:[NSNull null] forKey:columnName]; &#125; &#125; [array addObject:[dic copy]]; &#125; &#125; if (array.count &gt; 0) &#123; return [array copy]; &#125; return nil; &#125; return nil;&#125; 当在取得表中，具体的对象时，由于 sqlite3 中没有提供相应的函数直接获取整体，所以需要每个字段的获取。而在获取时，需要根据具体的数据类型判断来初始化对象。在 sqlite3.h 中将数据类型归结为：INTEGER、FLOAT、BLOB、TEXT 四种，所以分别判断数据类型，并使用相应的获取方法从 stmt 中获取值。 当数据需要修改时，需要用到 SQL 的 update 语句： 123456789101112- (BOOL)updateWithFactor:(NSString *)factor inTable:(NSString *)table&#123; if (![self open]) &#123; return NO; &#125; NSString *sql = [NSString stringWithFormat:@&quot;update %@ set %@&quot;, table, factor]; char *msg = NULL; int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg); return rt == SQLITE_OK;&#125; 通过这样的封装，我们尽可能的让使用库的人员少写数据库语句。但是这样做，实际上降低了库的灵活性，应对简单的场景都比较捉襟见肘，复杂就更别说了。 SQLite的缺点上一节的例子中，我们看到了想要直接使用 sqlite 数据库，几乎都是 c 语言，一定程度上增加了开发难度。并且我所制作的简单库适用性还很片面，或许只能在我所在的项目中使用。另外真实的数据库操作还包括：事务、多线程安全等。 如果要实现事务的话，那么在执行 BEGIN、COMMIT、ROLLBACK 操作需要用到以下语句： 123sqlite3_exec(_database, &quot;BEGIN&quot;, NULL, NULL, &amp;msg)sqlite3_exec(_database, &quot;COMMIT&quot;, NULL, NULL, &amp;msg)sqlite3_exec(_database, &quot;ROLLBACK&quot;, NULL, NULL, &amp;msg) 对于多线程安全，在提交操作 UPDATE、INSERT、SELECT 等操作时，需要自定义一个串行队列，按照入栈顺序依次执行。方案如下： 方案是现成的，只是实现问题而已。 上面分析的无疑会给开发增加难度。所以需要有这么一个轮子来帮我们做这些工作，而 FMDB 正是这样的一个库。 FMDBFMDB 是一套基于 SQLite 的数据库框架，它将原有的 c 语言库进行了面向对象的封装，并且通过串行队列保证了线程的安全。但是由于它使用 Objective-C 封装的，所以丧失了 SQLite 原本的跨平台特点，而只能在 iOS 中使用。 在 FMDB 中提供了4个类： FMDatabase，表示一个单独的 SQLite 数据库实例。通过封装，可以使用面向对象的技术对数据库进行增删改查等操作； FMDatabaseQueue，使用串行队列，实现对多线程的支持； FMDatabasePool，使用任务池的方式，实现对多线程的支持（官方不推荐：Before using FMDatabasePool, please consider using &lt;FMDatabaseQueue&gt; instead.）； FMResultSet，数据库查询结果对象。 和上章节提到的实现数据库线程安全的方案相同，FMDatabaseQueue 也是将所有的操作 block 都放到了一个 Serial 的串行队列中： 12_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL); 第一句代码其实就是新建一个串行队列 _queue 由于执行数据库操作。防止多线程操作数据库导致死锁的精髓就在第二句。dispatch_queue_set_specific 函数的作用是将 (__bridge void *)self 和 _queue 关联起来，而为什么要这样关联，请看下面： 12345678910111213141516171819202122232425262728293031323334353637/* * A key used to associate the FMDatabaseQueue object with the dispatch_queue_t it uses. * This in turn is used for deadlock detection by seeing if inDatabase: is called on * the queue&apos;s dispatch queue, which should not happen and causes a deadlock. */static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;- (void)inDatabase:(void (^)(FMDatabase *db))block &#123;#ifndef NDEBUG /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue * and then check it against self to make sure we&apos;re not about to deadlock. */ FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);#endif FMDBRetain(self); dispatch_sync(_queue, ^() &#123; FMDatabase *db = [self database]; block(db); if ([db hasOpenResultSets]) &#123; NSLog(@&quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&quot;); #if defined(DEBUG) &amp;&amp; DEBUG NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&quot;_openResultSets&quot;] copy]); for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) &#123; FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue]; NSLog(@&quot;query: &apos;%@&apos;&quot;, [rs query]); &#125;#endif &#125; &#125;); FMDBRelease(self);&#125; 宏定义 NDEBUG 的作用是将断言宏 assert 替换为无意义的代码（参考文档）。 在 inDatabase 中，首先获取了当前的队列所关联的对象，如果当前队列通过 kDispatchQueueSpecificKey 关联了对象，那么获取到的就是该对象，否则返回 nil 。通过下面的例子来说明一下： 1234567891011121314151617static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;NSObject *queueAssociateObject = [[NSObject alloc] init];dispatch_queue_t queue = dispatch_queue_create(&quot;SQLite.demo.queue&quot;, NULL);dispatch_queue_set_specific(queue, kDispatchQueueSpecificKey, (__bridge void*)queueAssociateObject, NULL);NSLog(@&quot;%@&quot;, queueAssociateObject);id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);NSLog(@&quot;%@&quot;, object);dispatch_sync(queue, ^&#123; id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); NSLog(@&quot;%@&quot;, object);&#125;); 打印结果为： 123SQLiteDemo[28346:1421335] &lt;NSObject: 0x102803100&gt;SQLiteDemo[28346:1421335] (null)SQLiteDemo[28346:1421335] &lt;NSObject: 0x102803100&gt; 可以看到，第二次输出的是获取 dispatch_main_queue 通过 kDispatchQueueSpecificKey 关联的对象，打印结果为 null ，因为 queueAssociateObject 是关联在 queue 上的，所以第三次打印就正确了。换句话说，通过 dispatch_queue_set_specific 能建立一个映射关系。 回到 inDatabase 中，当回去到当前队列所关联的对象后，如果关联对象和 self 相等，那么证明 inDatabase 也是在 _queue 中执行的，这就会造成多线程的死锁问题。所以使用了： 1assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;); 在开发阶段判断死锁，从而实现了线程安全。下面再举个例子说明下这里的死锁情况： 1234567891011121314dispatch_queue_set_specific(queue, kDispatchQueueSpecificKey, (__bridge void*)queueAssociateObject, NULL);NSLog(@&quot;%@&quot;, queueAssociateObject);dispatch_sync(queue, ^&#123; dispatch_sync(queue, ^&#123; id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); NSLog(@&quot;%@&quot;, object); &#125;); id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey); NSLog(@&quot;%@&quot;, object);&#125;); 到第二个 dispatch_sync 的时候就死锁了。 之所以要加上这样的判断是因为对数据库的访问可能是随机的、不同线程间（也可能是不同的网络回调等）的。内置一个 Serial 队列后，FMDatabaseQueue 并通过技巧判断后就变成线程安全了，所有的数据库访问都是同步执行。 接下来看看它对事务的支持： 12345678910111213141516171819202122232425- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &#123; FMDBRetain(self); dispatch_sync(_queue, ^() &#123; BOOL shouldRollback = NO; if (useDeferred) &#123; [[self database] beginDeferredTransaction]; &#125; else &#123; [[self database] beginTransaction]; &#125; block([self database], &amp;shouldRollback); if (shouldRollback) &#123; [[self database] rollback]; &#125; else &#123; [[self database] commit]; &#125; &#125;); FMDBRelease(self);&#125; 可以看到， FMDB 中的事务支持了延迟，当 useDeferred 为 true 时，使用事务不会立即获取锁，此时其他的线程货进程依然可以使用事务操作数据库，而数据库的上锁会直到需要锁的时候由 sqlite3 库本身添加。而如果我们不这样的搞笑操作时，它提供了友好的 API 操作，只需要将该字段传入 false 就能立即获取到排它锁（EXCLUSIVE），从而禁止其他任何情况对数据库的访问。 不知道为什么 FMDB 没有支持 IMMEDIATE 来实现 SHARED 锁？是因为目前绝大多数 App 都不没有这种应用场景？ FMDB 建立在 sqlite 3.7 版本之上，利用 SAVEPOINT 来实现更精确的 ROLLBACK ，源码在 FMDatabase.h 中： 1234567891011121314151617181920212223242526272829303132333435363738394041- (BOOL)startSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;#if SQLITE_VERSION_NUMBER &gt;= 3007000 NSParameterAssert(name); NSString *sql = [NSString stringWithFormat:@&quot;savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)]; return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];#else NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil); if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage); return NO;#endif&#125;- (BOOL)releaseSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;#if SQLITE_VERSION_NUMBER &gt;= 3007000 NSParameterAssert(name); NSString *sql = [NSString stringWithFormat:@&quot;release savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)]; return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];#else NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil); if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage); return NO;#endif&#125;- (BOOL)rollbackToSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;#if SQLITE_VERSION_NUMBER &gt;= 3007000 NSParameterAssert(name); NSString *sql = [NSString stringWithFormat:@&quot;rollback transaction to savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)]; return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];#else NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil); if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage); return NO;#endif&#125; 通过上面的代码对比，发现经过 FMDB 的封装后，数据库的操作更加面向对象化了。而且支持了多线程安全和事务。 但 FMDB 也并不是完美的，目前我发现由以下几个比较坑的： 由于查询结果封装在 map 中，所以不能直接获取基础数据类型，都是通过 NSNumber 或 NSValue 包装后的对象； 如果能将部分常用的 SQL 语句集成到库中，使用一时爽，一直使用一直爽（有点痴人说梦的感觉）；等等。 看完 FMDatabaseQueue 实现多线程安全和事务后，再来看看 FMDatabasePool 是怎么做的？ 从源码可以看出，Pool 中增加了两个属性：_databaseInPool、_databaseOutPool，用于存放同一个路径对应的数据库抽象对象 FMDatabase 的实体。每次，当执行 inDatabase 方法时，首先从 _databaseInPool 中去获取数据库对象，如果获取到了，那么将起放到 _databaseOutPool 中，如果没有取到，那么考虑初始化一个数据库对象，当数据库通过用户代理设置无需加入到 Pool 中时，直接关闭数据库连接，释放数据库对象不执行数据库操作，当代理方法返回 true 时将其放入到 _databaseOutPool 中管理。 当然，官方给出了一条建议： If you really really really know what you’re doing and FMDatabasePool is what you really really need (ie, you’re using a read only database), OK you can use it. But just be careful not to deadlock!ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD 小结在这篇文章中，我从基础的 SQLite 使用到 FMDB 进行了探讨和研究，不仅仅使用到了数据库的知识：增、删、查、改和锁，还学习到了 FMDB 在解决多线程死锁时使用的技巧，通过 dispatch_queue_set_specific() 函数关联对象和队列，通过对象相等变相推断队列相同，从而避免了线程死锁。]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对 CoreAnimation 进行封装，实现链式调用]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%AF%B9%20CoreAnimation%20%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[动画在 iOS 开发中可谓是见惯不怪了，实现动画的方式多种多样。你可以使用 facebook 的 pop，基于 CADisplayLink 自行实现，也可以基于系统提供的 api 进行开发。 这篇文章是基于系统的 CoreAnimation 库进行二次封装，实现动画的链式调用。由于最近比较痴迷于 Swift ,所以代码使用该语言实现，但是思路是相同的，喜欢的可以自己实现一套 Objective-C 的链式动画库。 为什么我要做这个库正如开篇所说，动画的使用太多了，而 CA 框架的动画实现太过于呆板，而且巨繁琐。如果一个项目只有少数的动画效果需要实现，这样使用问题不大，但是大量动画着实虐心。 既然无法减少动画的开发，那么有没有什么办法让动画的实现不再那么无聊甚至无趣（至少对简单动画而言）。所以，考虑到这点，我就动手做了一个能够实现简单动画的链式封装。当然，能力有限，目前只是针对 Basic 和 Group 两种动画的链式封装。 我是如何设计这个库的 如图所示，我通过一个中间类来统一管理所有的动画对象，当触发 run 时动画开始执行。通过这样的设计，我将整个库需要完成的功能以及提供的接口方法都一并用接口的方式实现了，具体我们在下一章节中来看看实现上的细节。 代码实现初始化方法提供了两个，一种是直接使用 layer 初始化，另外一种是使用 view 初始化： 123456789private weak var layer: CALayer!init(layer: CALayer) &#123; self.layer = layer&#125; convenience init(view: UIView) &#123; self.init(layer: view.layer)&#125; 而动画执行必须要等到 run 方法触发后才能执行，所以需要一个集合来存放已经初始化了的动画对象： 1private var animations: [(key: String, anim: CAAnimation)] = [] 动画对象的存储使用了数组嵌套元组的结构，能够方便我们在寻找对应的动画对象时效率较高，存储意义也明确。而在关联动画的“寻址 key”时，为了方便使用方使用，在使用者不想绞尽脑汁想 key 时，我也提供了默认的 key 使用： 123private func _animKey(_ key: String? = nil) -&gt; String &#123; return key ?? &quot;com.YSChainAnimator.anim.count_\(animations.count)&quot;&#125; 当你需要添加一个动画对象时，内部实现一个公用的方法实现添加动画到动画管理容器中，后续直接调用即可： 12345@discardableResultfunc _add(_ key: String? = nil, anim handler: () -&gt; CAAnimation) -&gt; Self &#123; animations.append((key: _animKey(key), anim: handler())) return self&#125; 该方法通过闭包的方式，将动画的初始化放由使用者决定，一定程度上提高了库的灵活性。私有方法介绍后，看看公共接口是如何实现的。 1234567891011121314151617181920212223242526272829303132333435363738@discardableResultfunc anim(_ keyPath: String, key: String? = nil) -&gt; Self &#123; return _add(key) &#123; let anim = CABasicAnimation(keyPath: keyPath) anim.duration = 1.0 return anim &#125;&#125;@discardableResultfunc group() -&gt; Self &#123; if animations.count == 0 &#123; print(&quot;Group animation ocurred error, because there are any animation in animator.&quot;) &#125; else &#123; let _animations = animations animations.removeAll() _add(&quot;com.YSChainAnimator.anim.group.count_\(animations.count)&quot;) &#123; () -&gt; CAAnimation in let group = CAAnimationGroup() group.animations = _animations.compactMap &#123; $0.anim &#125; return group &#125; &#125; return self&#125; func run() &#123; for animate in animations &#123; layer.add(animate.anim, forKey: animate.key) &#125; animations.removeAll()&#125; @discardableResultfunc modify&lt;T: CAAnimation&gt;(anim handler:(T?) -&gt; Void) -&gt; Self &#123; handler(animations.last?.anim as? T) return self&#125; 简单的动画默认动画时间为1s；group 是将之前所有加的动画全部都使用组动画进行包装。为了方便对更精确的属性进行修改，提供一个 modify 方法，另外如果还有更详细的动画属性需要设置，使用方也可以自己调用方法进行设置。精确的方法实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@discardableResultfunc duration(_ d: CFTimeInterval = 1.0) -&gt; Self &#123; return modify &#123; $0?.duration = d &#125;&#125; @discardableResultfunc from(_ v: Any?) -&gt; Self &#123; return modify &#123; if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123; print(&quot;Modify last animation `fromValue` ocurred error, because it&apos;s an group animation.&quot;) &#125; else &#123; ($0 as! CABasicAnimation).fromValue = v &#125; &#125;&#125; @discardableResultfunc to(_ v: Any?) -&gt; Self &#123; return modify &#123; if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123; print(&quot;Modify last animation `toValue` ocurred error, because it&apos;s an group animation.&quot;) &#125; else &#123; ($0 as! CABasicAnimation).toValue = v &#125; &#125;&#125; @discardableResultfunc by(_ v: Any?) -&gt; Self &#123; return modify &#123; if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123; print(&quot;Modify last animation `byValue` ocurred error, because it&apos;s an group animation.&quot;) &#125; else &#123; ($0 as! CABasicAnimation).byValue = v &#125; &#125;&#125; @discardableResultfunc timing(_ v: CAMediaTimingFunction) -&gt; Self &#123; return modify &#123; $0?.timingFunction = v &#125;&#125; @discardableResultfunc hold() -&gt; Self &#123; return modify &#123;#if swift(&gt;=4.2) $0?.fillMode = CAMediaTimingFillMode.forwards#else $0?.fillMode = kCAFillModeForwards#endif $0?.isRemovedOnCompletion = false &#125;&#125; 方法实现相对比较简单，都是通过调用 modify 方法实现的，当然如果这些便捷方法不满足需求，使用方还可以自己调用该方法实现。hold 方法是常规的对动画完成后的停留属性的包装。这里就是 modal 和 presentation 的区别了，设计到比较底层的 CoreAnimation 的知识，这里做一个引子，后续如果有时间，再来仔细研究该框架。 为了更贴切的监听动画的状态，还需要增加对动画开始和结束的回调： 1234567891011121314151617181920212223242526272829extension YSChainAnimator &#123; private class AnimationDelegate: NSObject, CAAnimationDelegate &#123; private let begin: AnimatingClosure? private let end: AnimatingClosure? init(begin: AnimatingClosure?, end: AnimatingClosure?) &#123; self.begin = begin self.end = end &#125; func animationDidStart(_ anim: CAAnimation) &#123; begin?(anim) &#125; func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; end?(anim) &#125; &#125; @discardableResult func animating(begin: AnimatingClosure?, end: AnimatingClosure?) -&gt; Self &#123; animations.last?.anim.delegate = AnimationDelegate(begin: begin, end: end) return self &#125; &#125; 这个地方，使用一个私有类来实现对 CoreAnimation 的动画代理方法的实现，进而可以统一管理回调。 小结这篇文章是对开发中繁琐功能的简化封装，在封装过程中设计到了“工厂设计模式”的体现。通过使用 Swift 来实现，一方面学习了新的语言。另外，感到这门语言着实让人吃惊，简洁但又明确，相信在不久的将来（等它比较稳定的将来）应该能够替换 Objective-C 。使用先设计，再开发的步骤有效的提高了编码的质量，以后应该多使用这样的方式开发。]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[当 MVVM 邂逅 RxSwift]]></title>
    <url>%2F2019%2F04%2F18%2F%E5%BD%93%20MVVM%20%E9%82%82%E9%80%85%20RxSwift%2F</url>
    <content type="text"><![CDATA[MVVM 起源于2005年，由微软的架构师 John Gossman 提出的一种架构模式，并在 WPF 和 Silverlight 中使用。它是 MVC 的一种衍生架构，通过“绑定”机制将 Controller 中的业务代码脱离出来，从而促进了 UI 层与逻辑代码的分离。 RxSwift 是 ReactiveX 的 Swift 版本，扩展了观察者模式，是一套基于异步事件的响应式编程框架。 这两个神奇的技术碰撞到一起会有什么样的火花呢？下面，我将从以下几方面来简述我在使用它们时的一些感悟（纯属个人理解）：MVC、MVVM、RxSwift、MVVM邂逅RxSwift MVCMVC 可以说是一套最经典的客户端开发架构，同时苹果官方也是极力推崇的架构模式。它将项目分为：Model、View、Controller 三个层级，它们的关系如下图所示： 上图清晰的展示的它们三者的关系，Model 代表数据，View 带边视图，Controller 则负责帮助它们建立关系： Model：指模型，数据的抽象，表示业务规则； View：用户界面，展示模型返回的数据，接受并传递用户交互； Controller：响应用户交互，并映射为用户行为，从而修改模型数据指示界面更新。 Controller ，通过 data source 和 delegate 来更新视图，通过 outlet 持有视图。View 则通过 action-target 的方式传递用户事件。同时 Controller 接收到 View 传递的事件后直接修改持有的 Model ，引发 Model 的观察者（KVO）或通知机制告知 Controller ，data source 需要工作来更改 View。 这样的工作方式看起来井井有条，实际上却很难有效得将这三者区分开来，特别是苹果还设计了 UIViewController ，这就更加难于区分 Controller 和 View 了。在我看来苹果设计的 UIViewController 只是为视图提供一个容器，也就是说 Controller 中的 view 属性应该叫做 view container 更为贴切。 另外，由于 View 和 Model 相互独立，导致了 Controller 中的业务代码会随着业务的增加而日益庞大起来，最终导致了 Massive View Controller 的出现，使 Controller 不利于维护。再加上网络层在该框架下也并没有确切的定位，也导致了网络放哪里都不合适的错觉。 提示：在服务端的开发中，javabean+jsp+servlet，能够很贴切的体现 MVC 架构思想。 MVVM由于 MVC 在实现时，不易区分各个功能模块的界线和 Controller 过于厚重等问题被暴露后，由微软架构师 John Gossman 在 MVC 的基础上优化衍生，并于2005年提出的 MVVM 则完美的解决了这一问题，促进了 UI 和业务逻辑的分离。 首先，在 MVVM 中，项目被分为了：Model、View、ViewModel 3个模块： 通过上图，可以看出，实际上新架构中的 ViewModel 抢去了原来 Controller 的部分工作，从而解决了控制器过于厚重的问题。而它们的关系如下图所示： 我们可以这样理解它的各个模块： Model：和 MVC 中的一致，依然表示对数据的抽象，体现了业务的规则； ViewModel：新架构增加的中间层，用于管理视图和模型之间的相互影响的因果关系。换句话说：模型的改变可能会影响视图对应的改变，而视图的改变也可能会引发模型作出相应的改动，最初这部分工作是由控制器来做的，现在 MVVM 中则由 ViewModel 来实现，而至于它们之间的相互影响的关系是使用 KVO 还是 Rx 只是具体的实现技术而已，与架构本身并没有关系； View：将模型返回的数据用最高可读性的方式表达给用户，响应并传递用户交互； 我认为这三个模块并不完整，因为项目中有众多的 View 和 ViewModel ，然而它们的关系需要 Controller 来建立，也就是“绑定”，所以还应该补充一点： Controller：完成 View、ViewMode 二者的关系建立。 经过这样的演进，最终大量的逻辑代码将被移动到 ViewModel 中，从而 Controller 只需要管理视图以及视图和 ViewModel 之间的绑定关系，达到了更轻量级的控制的目的。同时，无处安放的网络请求也将由 ViewModel 实现，并提供 Command 的接口给 Controller 调用。 另外，由于 UIViewController 和 UIView 只是不同的组件而已，在苹果的实现中通常都是对应出现的，能看到 View ，那么就一定能找到一个对应的 Controller ，能出现一个 Controller ，也一定能找多至少一个 View ，所以索性就将它们两个看成一个模块，只是递进关系不同，功能存在包含而已。基于这样的考虑，我在项目结构上大致如下： 12345678910111213141516171819-------------------------| ... || || Model || || | /|\ || | | || \|/ | || || ViewModel || || | /|\ || | | || \|/ | || || View &amp; Controller || || ... |------------------------- 这是一个比较受争议的划分，只是在我看来如果非要严格的区分控制器和视图，在某种情况下会让架构失去灵活性，增加开发难度，不利于实践使用。例如：我要实现一个全局配置的功能，实际上我只需要很少量的视图组件就能完成，这个时候还非得区分 View 和 Controller，反倒没有直接将 UIViewController 即看作控制器又看作视图来的直接，而真正的业务模块的确应该坚持职责单一原则，区分得足够详细，后期维护就能够事半功倍。 我们再将视线移回到模块职业上。 MVVM 作为 MVC 的升级版，优化了随着业务的增加导致了 Controller 逐渐臃肿等问题，那么升级过后的模块又是怎么样的职业划分的呢？ 首先，模型做为数据的抽象，它体现了业务的形态，所以模型的实现一定是根据具体业务进行抽象，例如：我们有一个网上的商品交易系统，现在要做商品的买卖需求。在这个需求中，买东西一定需要定位到单一的商品，买家和卖家也一定要形成唯一关系，从而我们在设计 order 模型时，一定就需要有字段能够接受商品的唯一id，卖家的唯一id和买家的唯一id，这样一来，谁要买谁的什么商品的需求就抽象成 order 的模型来体现了！ 所以在我看来，如果模型所做的事情超出了了业务形态的范围，那么就不算是一个优秀的设计。当然，作为数据的载体，它也应该提供相应的数据读写接口，供其他模块调用。（这也是我认为“胖 model”不合理的原因） 接下来再来看看重头戏：ViewModel。作为 Controller 的小弟，它帮助控制完成了大量的工作，那么那些工作应该由它来做呢？我归纳了以下几点（可能有点片面）： 使用抽象模型作为载体修改和更新数据。数据作为系统核心价值的体现，用户通过点击、拖拽等操作 View ，通过 ViewModel 来控制模型进而修改数据，一方面这样能够降低核心数据被恶意窜改的风险，另外，对开发者而言，这样的设计能够提高代码的可维护性； 作为 View 和 Model 之间的桥梁，那么视图的显示逻辑部分应该由 ViewModel 来完成； 应该具备或持有 Model ，进而能够修改 Model 所代表的数据； 提供输入和输出接口，方便 Controller 进行绑定调用； 实现网络请求，并将结果序列化为对应模型。 其他… 以上的小点是我在使用中真实所使用到的场景，可能不全面，等遇到的时候再添加吧。 最后，Controller 作为控制器，应该管理视图容器（也就是自己的 view）的生命周期，生成子视图并放入到视图容器中一并管理，将 ViewModel 进行绑定完成特定的业务场景。 RxSwift上面我们有讲到实现 MVVM 无论采用 KVO 还是 Rx 都只是实现的技术不同而已，与架构本身没有关系。就 Rx 而言，它本身是一套基于异步事件的响应式框架而已。只是它让 MVVM 的实现更加优美，所以当提到 MVVM 的时候，首先想到的正是 Rx。起初在 RAC 还没有开发出来的时候，MVVM并不是如此火热（至少在 iOS 上是这样的），应该说是 RAC 奠定了 MVVM 的崛起。 Rx 是 ReactiveX 的缩写，而 ReactiveX 一个基于异步事件的响应式库。它基于观察者模式，支持异步数据和事件序列，通过简单的运算符就能实现对这些序列的订阅、组合、转换等，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。并且它还是一套跨平台的响应式标准，可以到达一处学会到处使用。 了解了 Rx 是什么之后，我们来了解下它作用是什么（至少在 iOS 中）？下面我们通过具体场景来看看它充当了什么角色： (1). 登陆界面中，我们有一个电话号的输入框，要求输入框需要验证电话号是否正确； 如果我们使用原始技术实现的话，我们可能会使用这几种事件传递的方法处理：delegate、notifinotion、target-action、KVO 等等； 而 Rx 则统一这些传递方法为信号传递，我们只需要将上面提到的方法全部替换为 rx 所代表的信号链就能完成相同的工作。 下面是一个简单示例，仅供参考： 123456789101112131415161718192021222324252627#program mark - 原始技术textField.addTarget(self, action: #selector(textField(didEditingChanged:)), for: .editingChanged)@objcfunc textField(didEditingChanged sender: UITextField) &#123; var text = sender.text if text.valid(type: .phone) &#123; // 这里实现通过电话验证的逻辑 &#125; else &#123; // 这里实现未通过电话验证的逻辑 &#125; // 最终逻辑&#125; #program mark - RxSwifttextField.rx.text.orEmpty .map &#123; // 实现电话号验证的逻辑 $0.valid(.phone) &#125; .subscribe &#123; // 最终逻辑 &#125; .disposed(by: disposeBag) (2). 在 MVVM 中，为数据绑定提供了更加方便及优美的实现方案。 当然，它的作用远不止于此，只是就本文的主题而言，我认为这两点已经足够了。 Observables 可以算是 Rx 的核心了，正是它让我们可以对任意异步事件柳进行随意的组合。例如：使用它来作为网络请求的返回值，那么我们从代码的阅读性上就可以看作是一次同步过的过程了，而处理回调只需要订阅它对应的事件即可： 123456789101112131415161718192021222324252627func resume() -&gt; Observable&lt;T&gt; &#123; return Observable&lt;T&gt;.create &#123; observer -&gt; Disposable in let request = Alamofire.request(self.url, method: self.method, parameters: self.parameters, encoding: self.encoding, headers: self.headers) .responseData &#123; if let error = $0.error &#123; observer.onError(error) &#125; else &#123; if let data = $0.data &#123; do &#123; observer.onNext(try JSONDecoder().decode(T.self, from: data)) observer.onCompleted() &#125; catch &#123; observer.onError(error) &#125; &#125; &#125; &#125; return Disposables.create &#123; request.cancel() &#125; &#125;&#125; 经过这样封装后的网络请求更像是同步的操作，因为发送后立即就能得到一个可观察的返回值，而我们只需要监听返回值的相应事件即可，一定程度上简化了异步的思想。 当然，以上两点只是 Rx 的一些应用而已，它的功能其实远不止于此，更多的内容还有待继续探究。 其实函数式编程和响应式编程还是有很大区别的，官方文档中式这样描述的： One main point of difference is that functional reactive programming operates on values that change continuously over time, while ReactiveX operates on discrete values that are emitted over time. 在这里我们就不具体讨论这两者的区别。 MVVM邂逅RxSwift通过上面的三个小章节，我们一起了解了 MVC ，MVVM 以及 RxSwift 。这章节中，我将以“登录”模块作为示例，简示 MVVM 和 RxSwift 会碰撞出什么样的火花。 需求：登录界面中需要填入用户名和密码“登录”按钮才能点击，点击后进行网络请求，成功提示“登录成功”，失败提示具体原因。 在实现 UI 时，我为了更好的区分 Controller 和 View，我将用户名输入框、密码输入框以及按钮放在了单独的 SignContentScrollView 中，并将这三个空间作为公用接口暴露出来，代码如下： 12345678910111213class SignContentScrollView: UIScrollView &#123; private weak var panguLogoImageView: UIImageView! private weak var titleLabel: UILabel! private weak var inputContainer: UIView! weak var usernameTextField: UITextField! weak var passwordTextField: UITextField! weak var signButton: UIButton! weak var forgetButton: UIButton! ...&#125; View 层算是解决了，接下来看看 ViewModel 应该如何设计？ ViewModel 作为视图和模型的桥梁，它不仅能够修改或获取模型，还能够响应用户交互和跟新用户界面，我更倾向于将它理解为一座“工厂”，用户界面给它提供“原材料”，经过加工后输出形成可直接使用的产品，这里的加工就是具体的业务逻辑了。结合 Swift 面向协议的特点，可以抽象一个 ViewModelType 的协议： 1234567891011121314151617181920212223242526272829303132fileprivate struct ViewModelTypeAssociateKey &#123; static var disposeBag: String = &quot;disposeBag&quot;&#125;protocol ViewModelType &#123; associatedtype Inputs associatedtype Outputs // 用于管理 Observable 的释放，通过协议的扩展直接给予默认值 var disposeBag: DisposeBag &#123; get &#125; var inputs: Inputs &#123; get &#125; var outputs: Outputs &#123; get &#125; &#125;extension ViewModelType &#123; var disposeBag: DisposeBag &#123; get &#123; guard let bag = (objc_getAssociatedObject(self, &amp;ViewModelTypeAssociateKey.disposeBag) as? DisposeBag) else &#123; let bag = DisposeBag() objc_setAssociatedObject(self, &amp;ViewModelTypeProtocolAssociateKey.disposeBag, bag, .OBJC_ASSOCIATION_RETAIN) return bag &#125; return bag &#125; &#125; &#125; 这样我们就有了一个协议来实现对所有 ViewModel 的公共抽象。它具有一个输入和一个输出的结构体，结构体中都会使用 Rx 的 Observable 的对象组成，通过对 Observable 订阅可以实现随时的监听。当落实到具体的登录业务时，ViewModelType 就可以这样实现了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class SignViewModel: ViewModelType &#123; struct Inputs &#123; let username: AnyObserver&lt;String&gt; let password: AnyObserver&lt;String&gt; let signCommand: AnyObserver&lt;Void&gt; &#125; struct Outputs &#123; let validSignSignal: Observable&lt;Bool&gt; let signStatusSignal: Observable&lt;RequestStatus&gt; &#125; var inputs: Inputs var outputs: Outputs private let usernameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) private let passwordSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) private let signCommandSubject = PublishSubject&lt;Void&gt;() private let signStatusSubject = PublishSubject&lt;RequestStatus&gt;() private var loginByNameApi: String &#123; get &#123; let paths = &quot;/&quot;+kSSODirectionPath+&quot;/&quot;+kLoginByNameApi guard let api = BaseURLModel.default.SSOApi else &#123; return paths &#125; return api+paths &#125; &#125; private var username: String = &quot;&quot; private var passowrd: String = &quot;&quot; init() &#123; inputs = Inputs(username: usernameSubject.asObserver(), password: passwordSubject.asObserver(), signCommand: signCommandSubject.asObserver()) outputs = Outputs(validSignSignal: Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125;, signStatusSignal: signStatusSubject) usernameSubject.asObserver() .bind(to: self.usernameBinder) .disposed(by: disposeBag) passwordSubject.asObserver() .bind(to: self.passwordBinder) .disposed(by: disposeBag) signCommandSubject .subscribe(onNext: &#123; [unowned self] in self._respondsToSignIn() &#125;) .disposed(by: disposeBag) &#125; private func _respondsToSignIn() &#123; self.signStatusSubject.onNext(.doing) YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi) .method(.post) .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;]) .resume() .subscribe(onNext: &#123; (response) in if response.code == 200 &#123; self.signStatusSubject.onNext(.success) &#125; else &#123; self.signStatusSubject.onNext(.failed(message: response.msg)) &#125; &#125;, onError: &#123; (error) in self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;)) &#125;) .disposed(by: self.disposeBag) &#125; &#125;extension SignViewModel &#123; private var usernameBinder: Binder&lt;String&gt; &#123; return Binder(self) &#123; $0.username = $1 &#125; &#125; private var passwordBinder: Binder&lt;String&gt; &#123; return Binder(self) &#123; $0.passowrd = $1 &#125; &#125; &#125; usernameSubject、passwordSubject、signCommandSubject 作为 inputs 的桥梁来链接外部参数和内部业务，可以让我们不需要通过方法将 input 和 output 进行转化，Controller 中只需要将输入信号和 inputs 中对应的信号绑定，内部就能通过桥梁信号监听相应的变化。 在 extension 中，通过数据绑定，将 usernameSubject 和 passwordSubject 的改变值绑定至 username 和 password 中，就是用户的交互改变数据模型的操作，网络请求时就能直接使用正确的值作为参数进行传递，绑定代码如下： 1234567usernameSubject.asObserver() .bind(to: self.usernameBinder) .disposed(by: disposeBag) passwordSubject.asObserver() .bind(to: self.passwordBinder) .disposed(by: disposeBag) 登录按钮的验证通过对 usernameSubject、passwordSubject 的组合，验证用户名和密码是否合规，最终转化为 Observable&lt;Bool&gt; 的对象，供按钮的 isEnable 直接绑定： 1Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125; 登录的状态也通过 let signStatusSignal: Observable&lt;RequestStatus&gt; 提供外部接口，直接观察状态的改变实现成功或失败的提示。（注：我认为 Controller 做页面的跳转和各种弹窗是必要的工作，所以我将这些放在控制器中做。） 最后，当按钮点击后，通过 signCommand 将按钮点击事件传递进来，内部通过订阅取得对应事件并发送网络请求： 1234567891011121314151617private func _respondsToSignIn() &#123; self.signStatusSubject.onNext(.doing) YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi) .method(.post) .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;]) .resume() .subscribe(onNext: &#123; (response) in if response.code == 200 &#123; self.signStatusSubject.onNext(.success) &#125; else &#123; self.signStatusSubject.onNext(.failed(message: response.msg)) &#125; &#125;, onError: &#123; (error) in self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;)) &#125;) .disposed(by: self.disposeBag)&#125; 这里我提一句，得益于 Swift 的范型特点，我们做网络请求时可以取得准确的数据模型。 由于 Swift 是一门数据严谨的语言，所以在模型设计上就不会想 Objective-C 一样那么灵活了。这里我通过示例简单的展示下我遇到的坑，及解决办法： 12345678910typealias ModelType = Codable &amp; DescriptionDebugablestruct BaseModel&lt;T: ModelType&gt;: ModelType &#123; var code: Int var msg: String var success: Bool var data: DataWithStringType&lt;T&gt;! var progressTask: ProgressTask? var errors: [ErrorModel]?&#125; 很明显，我所在的项目中 data 字段是所有的有用字段的集合。坑就在这里，当请求正确无误时，data 字段是正确的数据结构，而当请求错误时，服务端将 data 字段设置为一个字符串了，而在 Swift 中，数据类型是唯一确定的，我们不能将 data 字段即设置为一个数据结构又设置为一个字符串。而解决办法就是 – 转化，所以增加了一个 DataWithStringType 的模型，用于判断当前值是否为结构体，如果是，那么就归档到 entity 中，否则就归档到 string 中： 12345678910111213141516struct DataWithStringType&lt;T: ModelType&gt;: ModelType &#123; var string: String? var entity: T? init(from decoder: Decoder) throws &#123; let singleValueContainer = try decoder.singleValueContainer() if let stringValue = try? singleValueContainer.decode(String.self) &#123; string = stringValue &#125; else if let entityValue = try? singleValueContainer.decode(T.self) &#123; entity = entityValue &#125; &#125; &#125; 当所有的准备工作完成后，来看看 Controller 是如何将 ViewModel 和 View 绑定的： 12345678910111213141516171819202122232425262728293031func bindingViewModel() &#123; scrollView.usernameTextField.rx.text.orEmpty .bind(to: signVm.inputs.username) .disposed(by: signVm.disposeBag) scrollView.passwordTextField.rx.text.orEmpty .bind(to: signVm.inputs.password) .disposed(by: signVm.disposeBag) scrollView.signButton.rx.tap .bind(to: signVm.inputs.signCommand) .disposed(by: signVm.disposeBag) signVm.outputs.validSignSignal .bind(to: scrollView.signButton.rx.isEnabled) .disposed(by: signVm.disposeBag) signVm.outputs.signStatusSignal .subscribe &#123; [unowned self] in self.view.endEditing(false) switch $0.element! &#123; case .doing: self.view.makeActivityWithText(&quot;正在登陆&quot;, userInteraction: false) case .success: self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activitysuccess&quot;), text: &quot;登陆成功&quot;) case let .failed(message): self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activityerror&quot;), text: message) &#125; &#125; .disposed(by: signVm.disposeBag)&#125; 这样整体看起来，代码的模块性十分的良好。vm 甚至可以单独拿出来进行测试。当内部的业务逻辑需要更改时，几乎可以只动 vm 中的代码就能实现变更。并且在响应上，由于是绑定关系，那么逻辑链路还是相对明显的。举个例子： 123scrollView.passwordTextField.rx.text.orEmpty .bind(to: signVm.inputs.password) .disposed(by: signVm.disposeBag) 将密码的输入绑定到 vm 的 username，而该对象通过 passwordSubject转接到 vm 中执行相应业务逻辑。 小结在这篇文章中，通过在真实的项目中使用 Rx 和 MVVM 实现“登录”的需求来学习这二者。我认为重点是对于 vm 的设计和 Controller 如何进行数据绑定的。另外，至于 MVVM 中每个模块应该干什么，还是任重道远啊。 博文推荐： 深入理解MVC iOS 关于MVC和MVVM设计模式的那些事 iOS应用架构谈 view层的组织和调用方案 MVVM 介绍 RxSwift + MVVM: how to feed ViewModels]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从 WWDC 2018 220 Session 窥探 Auto Layout]]></title>
    <url>%2F2019%2F03%2F28%2F%E4%BB%8E%20WWDC%202018%20220%20Session%20%E7%AA%A5%E6%8E%A2%20Auto%20Layout%2F</url>
    <content type="text"><![CDATA[苹果公司早在 iOS 6 系统中就引入了 Auto Layout ，到目前为止，开发人员进行界面布局大致可以分为两类： Frame 、 Auto Layout 。使用 Frame 进行布局的开发者认为，这种方式更精确，并且性能优良，然而该方式过于原始，一方面在界面维护性差（杠精可能不这么觉得），另一方面在多屏幕适配上让人头疼。使用 Auto Layout 的开发者则认为，该方式在屏幕适配上占尽优势，在加入 了Interface Builder 后更是将“所见即所得”体现得淋漓尽致，但是最终形成视图显示时任然还是落实到 origin 和 size 上，从而中间会多出大量的根据约束、优先级等计算位置和大小的操作，一定程度上降低了性能，而且使用不当还极易造成崩溃。 在 High Performance Auto Layout 中介绍说：苹果公司在 iOS 12 中大幅提高了Auto Layout的性能，使滑动达到了满帧。为了更清楚解释 Auto Layout ，我们将从以下几点进行探讨：运行过程 、自动布局的性能问题、自动布局的方案 运行过程Auto Layout 布局系统不仅仅是实现了 Cassowary) 算法来解决用户界面中哪些相等和不等的关系，引入了“约束”的概念来抽象界面关系。它还是一套完整的布局引擎系统，用来统一管理布局的创建、更新和销毁，它主导了整个界面的布局。 首先，来看看自动布局的渲染过程。 苹果将一个渲染循环分为了3个步骤：更新约束、布局和显示： 所有需要的视图会根据层级关系从顶至低依次调用updateConstraints来更新约束； 接着，每个视图都会g根据层级关系沿着从低至顶的顺序依次执行layoutSubviews来进行布局； 最终，获取到布局信息后，视图和布局一样的执行方式调用drawRect进行绘制，从而将内容显示在用户的屏幕上。 于是，基于此流程，苹果开放了一套 API 给开发者使用，目的就是避免大量的重复工作，导致性能的损失： setNeedsUpdateConstraints，将 view 标记为需要更新约束，并在稍后触发updateConstraitsIfNeed; updateConstraitsIfNeeded，系统自动调用该方法。但是只有被第1点标记了的 view 才会调用updateConstraints。该方法，开发者可以手动调用，但不需要重写。 updateConstraints，更新约束的方法。 setNeedsLayout，将 view 标记为需要重新布局，并在稍后自动触发layoutIfNeeded。当 view 的布局发生改变时，也会自动调用。 layoutIfNeeded，系统自动调用该方法。同样，只有被第4点标记的 view 才会调用layoutSubviews。该方法，开发者可以手动调用，但也不需要重写。 layoutSubViews，不能手动调用。 setNeedsDisplay，将视图标记为需要重新绘制，并且触发绘制循环执行drawRect。 drawRect，视图的绘制，不能手动调用。 现在我们已经知道了 view 根据 Auto Layout 的绘制流程了，并且对苹果提供的 API 有了更为清晰的理解。 最后，我们再来聊聊布局引擎（以下简称：Engine）在渲染过程中起到的作用： 在自动布局框架中，布局的计算核心是 Engine ，换句话说，我们从添加的约束到获取到 view 的大小和位置信息都是由 Engine 进行计算的。我们说 Auto Layout 实现了 Cassowary 算法，主导了界面的布局，更精确的说是 Engine 来完成。 当然，光从上图很难看出 Engine 在渲染过程中起到的作用，我们结合 WWDC 进行理解。下面是一段原话： When the constraint is added what will happen is that we make an equation, which corresponds to the constraints, and we add that equation to the engine. The last object to understand in the diagram is that the equation is in terms of variables where a variable is like, you know, if I hand you an equation and I say solve for X, X is a variable. The things that we need to solve for in this case is the frame data of a view. So there will be four variables for every view, which is the min X, the min Y, the width, and the height. 当我们给 view 添加约束（以下称：NSLayoutConstraint）时， Cocoa 会根据 NSLayoutConstraint 创建一个 Equation 的等式添加到 Engine 中，Engine 拿到等式后，依据 Cassowary 算法对 NSLayoutConstraint 中约定的变量（以下称：Variable）进行求解。求得结果后 view 通过 layoutSubviews 将 Engine 中的 Frame 拷贝出来，以供显示绘制使用。我们来看看代码是如何转化为 Equation 的： 1234567[NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:view2 attribute:NSLayoutAttributeLeft multiplier:1 constant:10] Equation =&gt; 1view1.left = view2.left * 1 + 10 其中 view1.left 就是 NSLayoutConstraint 设置的 Variable ，需要 Engine 进行求解。 经过这样的理解，我将我的理解绘制成这样一幅简图： 上图中，我将 Engine 的工作这样理解：每个 view 在显示自己之前即得到布局信息之前， Engine 会将视图、约束、优先级和固定大小通过计算转换成最终的 Frame ，在 Engine 中，每当约束发生变化就会触发名叫：Deffered Layout Pass 的容错处理，当这些工作完成后，视图的绘制也会随之一并完成。为了继续监听约束变化，渲染循环（ps：其实这里渲染循环和运行循环是否是同一个东西，查了很多资料也没说个所以然，但是不影响对 Auto Layout 的理解。所以先暂时叫 Application Run Loop 统一名称。）又进入监听约束变化的状态，等待下次响应。当监听到约束变化后，再次执行下一轮循环。 这里有相关的参考链接： Changing Constraints 自动布局的性能问题上面我们对 Auto Layout 的运行过程进行了探讨。不难看出相对于 Frame 布局而言， Auto Layout 多出了对约束的更新、计算等操作，肯定会对效率产生一定的影响。然而这些影响如果在一次 Display 所允许的时间范围之内完成（60次/s），那么无论对开发者还是用户而言，都是可以接受的。在这章，我们一起来探讨影响 Auto Layout 性能的因素，从根儿上去理解这些问题，对我们将来开发工程中的取舍会有一定的帮助。 上图是来 What’s New in Cocoa Touch 数据，从上图可以看出，无论是嵌套还是非嵌套的视图层级关系而言，在 iOS 12 优化了 Auto Layout 之后，基本上和手动布局一致，都不会因为视图数量或嵌套层数的增加而导致性能的损耗成指数上升。那么导致优化前，性能成指数损耗的锅就应该由 Cassowary 来背吗？ Cassowary is an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities. 就 Cassowary 算法本身而言，是1997年就被发表并被称作高效的线性方程求解的算法，解决的是界面的线性规划问题，而线性规划问题的解法是单纯型法–Simplex。单从 Simplex 算法看，大多数情况下是没有呈指数时间复杂度的。而 Cassowary 是在 Simplex 的基础上，为解决用户界面实践中的应用和改进算法，最重要的是提出了“增量”的概念。从这个维度上来看， Cassowary 不能背这口黑锅。 那么，如果 Cassowary 算法本身是没有问题的话，那就只可能是 iOS 12 之前在实现算法时，并没有体现出增量的概念。 在 WWDC 2018 220 Session 中提到，系统从 Engine 中获取 view 的大小可分为以下几步： 创建一个 Engine 对象； 约束被添加到 Engine 中； Engine 计算出所有的布局信息； view 从 Engine 中拷贝出布局信息； Engine 对象呗销毁。 咋眼一看似乎没有什么问题，但是如果每次细微的更新约束都需要从0开始，新的计算引擎对象都要重新计算，当约束变关系变多时，最终会导致计算量的指数上升。 显然苹果早就注意到这个问题，在 iOS 12 中找到了并实现了解法。当然，性能是否真的如视频所说？这里有一篇文章，对 Auto Layout 进行了比较深入的测试：点击查看。 综上所述，尽管苹果一直在对 Auto Layout 进行优化升级，但目前为止，任然不如 Frame 布局来的直接、有效，然而这只是在相对极端的情况下才会出现，通常我们遇到的开发需求中是不会出现这种情况的。最终我们可以粗暴的认为： Auto Layout 具有了和手写布局几乎一致的高性能。 自动布局的方案除了上面探讨的 Auto Layout 性能问题之外， Auto Layout 框架的易用性也是影响其使用的关键因素之一。苹果公司自然比我们更清楚这一点的重要性。所以，后来又提供 VFL 这种 DSL 语言来简化 Auto Layout 的写法。再到后来，苹果紧随前端响应式布局– Flexbox 的思路，基于 Auto Layout 封装了 UIStackView 来提高响应式布局的开发效率。当然，这里我们不去着重探讨上述的布局方案，而是简单阐述以下几种 Auto Layout 方案的优缺点，以供大家选择： NSLayoutConstraint 实现 Auto Layout 上述我们提到了苹果使用 NSLayoutConstraint 来体现了 Cassowary 的约束的概念，并且苹果在 Auto Layout 框架中也只提供了它所对应的一套 API 供开发者使用，也就是说任何基于自动布局技术的其他方案都必然会通过 NSLayoutConstraint 来实现。 从上面的代码中，可以看出 NSLayoutConstraint 的可阅读性还是很好的，然而对开发过程中，多如牛毛的约束，显然这种方式是不可取得，太影响开发效率了。 苹果自家的可视化编辑方案：Interface Builder 我认为 Interface Builder 是一个革命性的突破。在没有它之前，我们的所有控件都必须通过代码初始化，设置 frame ，设置各种属性，然后 addSubview 到父视图上。这部分工作重复且毫无意义，直到 IB 的出现，它让 iOS 开发工程能够更容易的构建 App 的视图，并且更直观的进行视图编辑，只是简单的通过点击选择、拖拽等操作就可完成，最后通过 IBOutlet 将 IB 中的控件连接到代码中，供开发者直接使用。更多的时间都投入到业务开发中去，大大的提高了工程师的开发效率。（ps：我之前注意到，相同的需求，相同的迭代周期，相同的界面，Android由3个开发同时进行，iOS由2个开发同时开发，最终iOS完成迭代开发的时间早于Android2天，并且从高保真的还原度上而言也是得到了UI同事的赞扬的！） 难道 IB 真的就这么完美，找不出缺点吗？ 答案是否定的。 IB 在有如此高效且易用的有点下，缺点也是十分明显： IB 本质上也是一个 XML 文件，最终呈现成 view 时还是会转化成代码来完成，从而 IB 的执行效率低于手写代码； 在多团队开发中容易造成错误； 不利于代码的封装和工程架构的组织等； 学习成本相对较高。 Masonry 三方框架 你或许没有使用过 IB 进行界面开发，但是我相信 Masonry 你一定用过。它是基于 Auto Layout 的链式封装，不仅简化了 NSLayoutConstraint 带来繁杂的工作量，还更加清晰明了的解释了视图之间的约束关系。目前从我所经历的需求池看来， Masonry 都能够完成。毕竟是基于“老祖宗”的。虽然，时至今日，开发者也发现了很多它的问题，但这都是后话了，也不属于我们需要在这里探讨的话题了。 小结这篇文章是我在观看了 WWDC 2018 220和202 之后对 Auto Layout 一些感悟或者理解。我们从原理上探讨了自动布局技术的运行过程和自动布局的性能问题，并简单的提到了苹果在布局引擎中利用 Cassowary 算法进行线性规划问题的求解，对以后开发过程中遇到的问题能有更深层次的解释，自然也能更容易解决这些问题。又简单的总结了3中自动布局方案，并分别简述了各自的优缺点，希望能够为技术选型时提供一些参考。]]></content>
      <categories>
        <category>iOS 开发笔记</category>
      </categories>
  </entry>
</search>

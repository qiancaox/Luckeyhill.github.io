<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luckeyhill</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiancaox.github.io/"/>
  <updated>2019-01-23T09:07:39.000Z</updated>
  <id>https://qiancaox.github.io/</id>
  
  <author>
    <name>Luckeyhill.Xiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS-基于复用的同构分组卡片视图</title>
    <link href="https://qiancaox.github.io/2019/01/23/iOS-%E5%9F%BA%E4%BA%8E%E5%A4%8D%E7%94%A8%E7%9A%84%E5%90%8C%E6%9E%84%E5%88%86%E7%BB%84%E5%8D%A1%E7%89%87%E8%A7%86%E5%9B%BE/"/>
    <id>https://qiancaox.github.io/2019/01/23/iOS-基于复用的同构分组卡片视图/</id>
    <published>2019-01-23T09:07:39.000Z</published>
    <updated>2019-01-23T09:07:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>从iOS 11开发，系统多处采用了卡片式设计风格，加上一定程度上的阴影，提升了界面的立体感。当然不只是系统，淘宝、微信、京东等知名App的卡片也逐渐多了起来。</p><a id="more"></a><h2 id="做什么？"><a href="#做什么？" class="headerlink" title="做什么？"></a>做什么？</h2><p>虽然我所做的并没有那么复杂，但任然有一定的代表性：<br><img src="https://upload-images.jianshu.io/upload_images/1858049-18b16a98fd5c6728.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例-001"></p><h2 id="怎么做？"><a href="#怎么做？" class="headerlink" title="怎么做？"></a>怎么做？</h2><p>整个视图由三部分组成：</p><ul><li>每个单据对应的Item</li><li>多个单据的组合分组Section</li><li>滚动视图ScrollView</li></ul><p>事实上，有多种实现方案存在，但都各有优缺点：</p><ul><li>有多少个分组就添加多少个Section在<code>UIScrollView</code>上<blockquote><p>优点：快速、简单<br>缺点：当分组足够多时，对内存不友好，导致性能损失</p></blockquote></li><li>基于<code>UICollectionView</code>实现<blockquote><p>优点：支持复用，内存相对轻松<br>缺点：由于每个Item都在一个白底上，白底还有阴影和圆角，实现难度大（PS：我不知道怎么实现）</p></blockquote></li></ul><p>最终，我选择使用<code>UIScrollView</code>+复用实现。使用了复用之后自然内存消耗就能得到极大的优化，不过难点在于<strong>复用机制</strong>的实现。</p><h2 id="如何做？"><a href="#如何做？" class="headerlink" title="如何做？"></a>如何做？</h2><p><img src="https://upload-images.jianshu.io/upload_images/1858049-2672c1d9f660458a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例-002"><br>当然，仅仅这样做是远远不够的，不过通过<em>示例-002</em>可以清晰的知道大致有哪些模块。<br>首先，我们需要一个滚动视图<code>ICScrollView</code>，当做父容器；每个分组<code>ICScrollViewSection</code>作为子容器，放置每个入口按钮；<code>ICScrollViewItem</code>为每个按钮的实体对象。其次，还需要<code>ICScrollViewSectionRecord</code>来存储每个每个分组、分组中按钮的布局信息（<code>frame</code>）。</p><h2 id="重头戏-复用机制的实现"><a href="#重头戏-复用机制的实现" class="headerlink" title="重头戏 - 复用机制的实现"></a>重头戏 - 复用机制的实现</h2><p>在实现之前，先来重温一下<code>UITableView</code>的复用机制。由于列表视图的不可控因素，为了节省有限的内存资源，<code>cell</code>只会存在当前屏幕上显示个数的对象和极少数的缓存对象，某些<code>cell</code>会在使用完后自动释放，从而减轻对内存的依赖，实现内存优化的目的。<br>在第一次显示视图时，<code>UITableView</code>只会加载当前屏幕上能够显示的cell对象和预加载的cell（可复用的cell），如<em>示例-003</em>所示：<br><img src="https://upload-images.jianshu.io/upload_images/1858049-35762302ab19aee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例-003"><br>当手指滚动屏幕后，第一行cell移出屏幕，从屏幕上消失；第九行cell显示在屏幕上，第十行cell预加载，如<em>示例-004</em>所示：<br><img src="https://upload-images.jianshu.io/upload_images/1858049-88198f82797af52f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例-004"><br>说的还是比较笼统，实际上这里还是蕴含了很多细节，比如：</p><ul><li>cell布局如何进行？</li><li>cell如何预加载？</li><li>cell是如何放入到重用队列中，又是怎么从重用队列中取出？</li><li>重用队列如何排除以显示的cell？</li><li>力所能及的优化？<br>等等…..<br>这些问题，都将在代码部分一一实现。<h2 id="搬砖"><a href="#搬砖" class="headerlink" title="搬砖"></a>搬砖</h2>上面我对方案和技术点进行了简单的阐述，具体落实到代码又如何实现呢？<br>上面我们提到了一个类<code>ICScrollViewSectionRecord</code>，专门用来存储每个分组的布局信息（我这里是基于frame布局的），其中就包括了：header的高度、item的个数、item之间的间隔等等。但是重点不是这里，而是该分组实际应该占用的高度，以及每个item对应的rect如何计算和优化？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)sectionHeight &#123;</span><br><span class="line">if (_sectionHeight == 0 &amp;&amp; _updateSectionHeight) &#123;</span><br><span class="line">_updateSectionHeight = 0;</span><br><span class="line">int rows = ceil(((double)_numbersOfItems)/ICScrollViewItemCountPerRow());</span><br><span class="line">double spacing = (self.sectionWidth-ICScrollViewItemCountPerRow()*ICScrollViewItemSideLength())/ICScrollViewItemCountPerRow();</span><br><span class="line">_spacing = spacing;</span><br><span class="line">_sectionHeight = ICScrollViewSectionContentVerticalMargin*2 + rows*ICScrollViewItemSideLength() +(rows-1)*spacing + _headerHeight;</span><br><span class="line"></span><br><span class="line">// 优化滚动时，cpu占用率</span><br><span class="line">_rectCache = NSMutableDictionary.dictionary;</span><br><span class="line">for (int row = 0; row &lt; _numbersOfItems; row++) &#123;</span><br><span class="line">const NSInteger count = ICScrollViewItemCountPerRow();</span><br><span class="line">const CGFloat margin = ICScrollViewSectionContentVerticalMargin;</span><br><span class="line">const CGFloat length = ICScrollViewItemSideLength();</span><br><span class="line">CGFloat x = _spacing/2 + (row%count)*(length+_spacing);</span><br><span class="line">CGFloat y = margin + (row/count)*(length+_spacing) + _headerHeight;</span><br><span class="line">[_rectCache setObject:@(Rect(x, y, length, length)) forKey:@(row)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return _sectionHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGRect)rectForItemAtIndex:(NSInteger)index &#123;</span><br><span class="line">if (index &gt;= _numbersOfItems) &#123;</span><br><span class="line">return CGRectZero;</span><br><span class="line">&#125;</span><br><span class="line">return [_rectCache objectForKey:@(index)].CGRectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>_updateSectionHeight</code>是一个<a href="http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html" target="_blank" rel="noopener">位域</a>，用于判断当前调用<code>- sectionHeight</code>时，是否需要再次计算，因为当header高度和item个数变化时，都有可能导致分组高度发生改变。这里有两个优化点：</p><blockquote><p>1.用位域而不是BOOL（这里其实可以忽略）；<br>2.由于布局顺序，当在布局分组时，就提前计算好每个分组中，所有item的布局信息，在item布局时就可以直接从<code>_rectCache</code>中取数据，而避免在<code>scrollView</code>滚动时计算，一定程度上减轻cpu的压力。</p></blockquote><p>上面我只是调用了dataSource的方法，获取所有的分组布局数据，并没有将分组添加到视图上。当我拿到布局数组后，第一步应该是先确定<code>scrollView</code>的滚动范围：<code>contentSize</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)_setContentSize &#123;</span><br><span class="line">[self setUpdateRecordsIfNeeded];</span><br><span class="line"></span><br><span class="line">CGFloat height = 0;</span><br><span class="line">_spacing = _delegateHas.spacing ? [_delegate scectionsSpacingForScrollView:self] : 15.f;</span><br><span class="line">height += _spacing;</span><br><span class="line"></span><br><span class="line">for (ICScrollViewSectionRecord *record in _records) &#123;</span><br><span class="line">height += ([record sectionHeight] + _spacing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self setContentSize:Size(0, height)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>contentSize</code>的计算相对简单，只需要从<code>_records</code>数组中一一加上每个分组的高度和特定的分组间隔即可。所有的准备工作足够后，如何添加分组，分组如何复用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutScrollView &#123;</span><br><span class="line">const CGSize boundsSize = self.bounds.size;</span><br><span class="line">const CGFloat contentOffsetY = self.contentOffset.y;</span><br><span class="line">const CGRect visibleBounds = Rect(0, contentOffsetY, boundsSize.width, boundsSize.height);</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *availableSections = [_shownSections mutableCopy];</span><br><span class="line">const NSInteger numberOfSections = [_records count];</span><br><span class="line">[_shownSections removeAllObjects];</span><br><span class="line"></span><br><span class="line">for (int s = 0; s &lt; numberOfSections; s++) &#123;</span><br><span class="line">CGRect sRect = [self rectForSection:s];</span><br><span class="line">if (CGRectIntersectsRect(visibleBounds, sRect)) &#123;</span><br><span class="line">ICScrollViewSection *section = [availableSections objectForKey:@(s)];</span><br><span class="line"></span><br><span class="line">if (CGRectEqualToRect(section.frame, sRect)) &#123;</span><br><span class="line">[_shownSections setObject:section forKey:@(s)];</span><br><span class="line">[availableSections removeObjectForKey:@(s)];</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ICScrollViewSectionRecord *record =[_records objectAtIndex:s];</span><br><span class="line">if (section == nil) &#123;</span><br><span class="line">section = [self dequeueReusableSection];</span><br><span class="line">if (section == nil) &#123;</span><br><span class="line">section = [[ICScrollViewSection alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">section.cornerRadius = 7.f;</span><br><span class="line">[self addSubview:section];</span><br><span class="line"></span><br><span class="line">if (!section.header) &#123;</span><br><span class="line">[section addHeader:[[ICScrollViewHeader alloc] init]];</span><br><span class="line">section.header.frame = Rect(0, 0, 0, record.headerHeight);</span><br><span class="line">&#125;</span><br><span class="line">NSString *title = _delegateHas.headerTitle ? [_delegate scrollView:self titleForHeaderAtSection:s] : NSStringFormat(@&quot;Section - %d&quot;, s);</span><br><span class="line">section.header.label.text = title;</span><br><span class="line">&#125;</span><br><span class="line">section.frame = sRect;</span><br><span class="line">[_shownSections setObject:section forKey:@(s)];</span><br><span class="line">[availableSections removeObjectForKey:@(s)];</span><br><span class="line"></span><br><span class="line">const NSInteger numberOfItems = record.numbersOfItems;</span><br><span class="line">for (int r = 0; r &lt; numberOfItems; r++) &#123;</span><br><span class="line">if (_dataSourceHas.item) &#123;</span><br><span class="line">NSIndexPath *indexPath = [NSIndexPath indexPathForRow:r inSection:s];</span><br><span class="line">ICScrollViewItem *item = [_dataSource scrollView:self itemAtIndexPath:indexPath];</span><br><span class="line">if (item != nil) &#123;</span><br><span class="line">[section addSubitem:item];</span><br><span class="line">item.frame = [record rectForItemAtIndex:r];</span><br><span class="line">&#125;</span><br><span class="line">[item prepareForDisplay];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSMutableArray *didAddToDisplayItems = [section.items mutableCopy];</span><br><span class="line">for (int idx = (int)numberOfItems; idx &lt; didAddToDisplayItems.count; idx++) &#123;</span><br><span class="line">ICScrollViewItem *item = didAddToDisplayItems[idx];</span><br><span class="line">[section removeSubitem:item];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (ICScrollViewSection *section in availableSections.allValues) &#123;</span><br><span class="line">if ([section isKindOfClass:ICScrollViewSection.class]) &#123;</span><br><span class="line">[_reusableSections addObject:section];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSMutableArray *reusable = [_reusableSections.allObjects mutableCopy];</span><br><span class="line">for (ICScrollViewSection *section in reusable) &#123;</span><br><span class="line">if ([_shownSections.allValues containsObject:section]) &#123;</span><br><span class="line">[_reusableSections removeObject:section];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[_reusableSections.allObjects makeObjectsPerformSelector:@selector(removeFromSuperview)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较长，我来一步一步的解释下。<code>UIScrollView</code>之所以能够<strong>滚动</strong>是因为<a href="https://stackoverflow.com/questions/1210047/cocoa-whats-the-difference-between-the-frame-and-the-bounds" target="_blank" rel="noopener">bounds和frame的区别</a>。换句话说，当前屏幕上显示的<code>UIScrollView</code>的<code>visibleBounds</code>区域。<br>上面简述tableView的复用时提到，只会加载当前展示区域的视图，超出的将释放或存在重用队列中。所以我们依次取每个分组对应的frame，通过<code>CGRectIntersectsRect</code>判断两个frame是否存在交集，如果为<code>true</code>表示该分组应该显示在视图上。核心代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGRect sRect = [self rectForSection:s];</span><br><span class="line">if (CGRectIntersectsRect(visibleBounds, sRect)) &#123;</span><br><span class="line">// 加入显示逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如何复用section呢？沿用经典套路：先从当前显示的队列中取section，如果取到了，那么该section是存在的，并不需要再次添加到父容器上，如果不存在，那么从重用队列去取一个（因为我们这里是同构的，所以不需要用identifier区分）。如果任然没有，那么只能初始化一个了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/// 是否当前屏幕正在显示</span><br><span class="line">ICScrollViewSection *section = [availableSections objectForKey:@(s)];</span><br><span class="line"></span><br><span class="line">/// 如果正在显示，则执行下一次循环</span><br><span class="line">if (CGRectEqualToRect(section.frame, sRect)) &#123;</span><br><span class="line">[_shownSections setObject:section forKey:@(s)];</span><br><span class="line">[availableSections removeObjectForKey:@(s)];</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 如果不存在，则在重用队列中找寻一个</span><br><span class="line">if (section == nil) &#123;</span><br><span class="line">section = [self dequeueReusableSection];</span><br><span class="line">/// 如果任然没有实例，则只能初始化一个</span><br><span class="line">if (section == nil) &#123;</span><br><span class="line">section = [[ICScrollViewSection alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，能够在<code>visibleBounds</code>中显示的分组就已经添加完了。这时，由于整个显示情况已经进行了重新绘制，必须同步更新<code>_reusableSections</code>，为下次绘制做好准备。这里分为两步：</p><ul><li><p>将之前刚从屏幕上移除的，还在<code>availableSections</code>中的分组添加到重用队列中，哪怕可能重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (ICScrollViewSection *section in availableSections.allValues) &#123;</span><br><span class="line">if ([section isKindOfClass:ICScrollViewSection.class]) &#123;</span><br><span class="line">[_reusableSections addObject:section];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于，至始至终重用队列都只增加了分组，至于刚才已经从队列中取出去显示还没有排除开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *reusable = [_reusableSections.allObjects mutableCopy];</span><br><span class="line">for (ICScrollViewSection *section in reusable) &#123;</span><br><span class="line">/// 如果在重用队列中的刚好也在当前屏幕显示，则从重用队列移除</span><br><span class="line">if ([_shownSections.allValues containsObject:section]) &#123;</span><br><span class="line">[_reusableSections removeObject:section];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将重用队列中的分组从父视图上移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_reusableSections.allObjects makeObjectsPerformSelector:@selector(removeFromSuperview)];</span><br></pre></td></tr></table></figure></li></ul><p>在每次调用<code>layoutSubviews</code>时调用绘制方法即可完成视图得绘制 -&gt; 复用 -&gt; 重绘的功能。最终实现如下效果：<br><img src="https://upload-images.jianshu.io/upload_images/1858049-d7b48e2eed2cec44.gif?imageMogr2/auto-orient/strip" alt="示例-005"></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li>重用队列使用<code>NSMutableSet</code>能够很容易的去重。</li><li>取每个分组的rect时<code>CGRect sRect = [self rectForSection:s];</code>，如果在方法中加入缓存机制，能够在数据未改变时，极大的减少cpu的计算量，给cpu减压。</li><li>在判断显示时，如何减少循环次数？（目前未实现）<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>数据类型的别名：<blockquote><p>typedef NSMutableDictionary&lt;NSNumber<em>, ICScrollViewSection</em>&gt;<em> ICShownSectionDictionary;<br>typedef NSMutableSet&lt;ICScrollViewSection</em>&gt;<em> ICReusableSectionSet;<br>typedef NSMutableArray&lt;ICScrollViewSectionRecord</em>&gt;<em> ICSectionRecordArray;<br>typedef NSMutableDictionary&lt;NSNumber</em>, NSValue<em>&gt;</em> ICScrollViewSectionRectCache;<br>typedef NSMutableDictionary&lt;NSIndexPath<em>, NSValue</em>&gt;* ICScrollViewItemRectCache;</p></blockquote></li></ul><p>做完之后，同事说的阿里巴巴有个三方库<a href="https://github.com/alibaba/lazyscrollview" target="_blank" rel="noopener">LazyScrollView</a>，功能更强大，😭😭😭。我自己的项目地址<a href="https://github.com/qiancaox/SumOfExperience/blob/master/SumOfExperience/SEFramework/ICScrollView.h" target="_blank" rel="noopener">ICScrollView</a>，欢迎光临！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从iOS 11开发，系统多处采用了卡片式设计风格，加上一定程度上的阴影，提升了界面的立体感。当然不只是系统，淘宝、微信、京东等知名App的卡片也逐渐多了起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://qiancaox.github.io/categories/Objective-C/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yeeshe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://qiancaox.github.io/"/>
  <updated>2019-05-06T01:01:07.337Z</updated>
  <id>https://qiancaox.github.io/</id>
  
  <author>
    <name>yeeshe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 SQLite 到 FMDB，我经历了什么</title>
    <link href="https://qiancaox.github.io/2019/05/06/%E4%BB%8E%20SQLite%20%E5%88%B0%20FMDB%EF%BC%8C%E6%88%91%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://qiancaox.github.io/2019/05/06/从 SQLite 到 FMDB，我经历了什么/</id>
    <published>2019-05-06T01:00:28.648Z</published>
    <updated>2019-05-06T01:01:07.337Z</updated>
    
    <content type="html"><![CDATA[<p>移动端的纯在线 App 已经跟不上时代的节奏了，或多或少都会有一些数据需要本地存储。目前在 iOS 上有以下几种方式可供选择：</p><ol><li><code>NSUserDefault</code>，也称偏好设置。用于数据规模小，于业务无关的数据存储；</li><li><code>keychain</code>，苹果提供的带有可逆加密的存储机制，只要系统不重装，数据都能得到保留，并且支持 iClound 云同步，普遍用于各种存密码的存储和用户唯一标识串等；</li><li>文件存储：<ul><li>Plist 文件，也称属性列表。结构化较好或需要方便查询的数据可以选择；</li><li>Archive ，也叫归档/解档。如果需要直接对象化数据时使用，但是由于归档或解档时需要对对象序列化，耗时较多；</li><li>一般文件存储，由于文件在在读写时耗时，所以通常用在量比较小的数据上。</li></ul></li><li>CoreData，苹果官推的数据存储框架，笔者没使用过，这里有个文章可以看看：<a href="http://blog.devtang.com/2016/08/04/i-do-not-like-core-data/" target="_blank" rel="noopener">我为什么不喜欢 Core Data</a>；</li><li>数据库存储。</li></ol><p>说到数据库存储，目前流行的有： <a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">SQLite</a>、<a href="https://realm.io/" target="_blank" rel="noopener">Realm</a> 等方式在移动端使用。并且它们都有轻量级、跨平台的特点，而今天的主角是 SQLite 数据库。下面将从两方面来探讨下：<a href="#SQLite">SQLite</a>、<a href="#FMDB">FMDB</a></p><a id="more"></a><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite 是基于 C 语言实现的 SQL(结构化查询语言) 的轻量级关系型数据库的库。并且它还支持跨平台和读写速度快的特性，可以用于嵌入式和移动端的数据存储。但是，由于它没有单独的服务器进程，所以并不能够像 MySQL、Oracle、PostgreSQL 这些大型数据用于服务端的开发。</p><blockquote><p>SQLite does not have a separate server process.</p></blockquote><p>由于它是 C 语言的库，所以在使用过程中，通常都会进行一定的封装。让我们来看 SQLite 的简单使用。</p><p>首先，要想操作数据库，必须要初始化并打开对应的 <code>sqlite3</code> 对象，而且由于这个方法可能会多次调用，所以封装为公用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)open</span><br><span class="line">&#123;</span><br><span class="line">    NSString *dbPath = [self _databaseSandboxPathWithDBName:nil];</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    </span><br><span class="line">    if ([fileManager fileExistsAtPath:dbPath] == NO)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOL rt = [fileManager createFileAtPath:dbPath contents:nil attributes:nil];</span><br><span class="line">        if (!rt) &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int rt = sqlite3_open([dbPath fileSystemRepresentation], &amp;_database);</span><br><span class="line">    return rt == SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sqlite 库中，open 方法有3个，分别为：<code>sqlite3_open</code>、<code>sqlite3_open16</code>、<code>sqlite3_open_v2</code> ，其中前两个默认以可读可写的方式打开数据库，如果数据库不存在则创建一个。而第三个则提供给用户接口控制打开数据库的方式，该方式通过 flags 来控制。</p><p>与之对应的就是关闭数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)close</span><br><span class="line">&#123;</span><br><span class="line">    if (_database) &#123;</span><br><span class="line">        sqlite3_close(_database);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数据库打开后，就可以建表了。而建表就需要执行 SQL 语句了，作为简单得封装，我们只考虑用户输入表明和字段说明的语句，而完整的语句由库拼接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)createTableWithName:(NSString *)name fileds:(NSString *)fileds</span><br><span class="line">&#123;</span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;create table if not exists %@ (%@)&quot;, name, fileds];</span><br><span class="line">    if (![self open]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char *msg = NULL;</span><br><span class="line">    int rt = sqlite3_exec(_database, [sql UTF8String], nil, nil, &amp;msg);</span><br><span class="line">    </span><br><span class="line">    return rt == SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>sqlite3_exec</code> 接受5个参数，比较重要的是执行语句 <code>[sql UTF8String]</code> 、回调（第三个）和回调函数中的首个传递值（该函数中的第四个）。回调函数将会在执行查询时每查询到一条记录执行一次。</p><p>通常，使用数据库的核心和基础就是增、删、改、查。同样，也需要进行简单的封装才能使用。</p><p>当需要向表中插入一条记录时，封装以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)insertValues:(NSDictionary *)map inTable:(NSString *)table</span><br><span class="line">&#123;</span><br><span class="line">    if (![self open]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __block NSMutableArray *values = [NSMutableArray arrayWithCapacity:map.count];</span><br><span class="line">    __block NSMutableArray *keys = [NSMutableArray arrayWithCapacity:map.count];</span><br><span class="line">    [map enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        [keys addObject:key];</span><br><span class="line">        [values addObject:obj];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSString *keysString = [keys componentsJoinedByString:@&quot;, &quot;];</span><br><span class="line">    for (int i = 0; i &lt; values.count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        id value = values[i];</span><br><span class="line">        if ([value isKindOfClass:NSString.class]) &#123;</span><br><span class="line">            [values replaceObjectAtIndex:i withObject:[NSString stringWithFormat:@&quot;&apos;%@&apos;&quot;, value]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *valuesString = [values componentsJoinedByString:@&quot;, &quot;];</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;insert into %@ (%@) values (%@)&quot;, table, keysString, valuesString];</span><br><span class="line">    char *msg = NULL;</span><br><span class="line">    int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg);</span><br><span class="line">    </span><br><span class="line">    [self close];</span><br><span class="line">    </span><br><span class="line">    return rt == SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部只需要讲表格内容按照字段的方式传入，库会帮助拼接 SQL 语句。这里比较片面的是我只兼容了两种数据类型：text、integer，并且在拼接字符串时，只会给 text 加入单引号区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)deleteColumnWithFactor:(NSString *)factor inTable:(NSString *)table</span><br><span class="line">&#123;</span><br><span class="line">    if (![self open]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;delete from %@ where (%@)&quot;, table, factor];</span><br><span class="line">    char *msg = NULL;</span><br><span class="line">    int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg);</span><br><span class="line">    </span><br><span class="line">    [self close];</span><br><span class="line">    </span><br><span class="line">    return rt == SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要删除表格中的行时，需要按照条件 <code>factor</code> 进行 <code>where</code> 的过滤。但是由于查询时，数据的数据类型需要进行判断，所以代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)queryColumnsWithFactor:(NSString *)factor inTable:(NSString *)table</span><br><span class="line">&#123;</span><br><span class="line">    if (![self open]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;select * from %@ &quot;, table];</span><br><span class="line">    if (factor) &#123;</span><br><span class="line">        sql = [sql stringByAppendingString:[NSString stringWithFormat:@&quot;where (%@)&quot;, factor]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sqlite3_stmt *stmt = NULL;</span><br><span class="line">    int valid = sqlite3_prepare_v2(_database, [sql UTF8String], -1, &amp;stmt, NULL);</span><br><span class="line">    </span><br><span class="line">    if (valid == SQLITE_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableArray *array = [NSMutableArray arrayWithCapacity:0];</span><br><span class="line">        </span><br><span class="line">        // 只有当返回值位 SQLITE_ROW 时表示有值查询出来，需要进一步解析</span><br><span class="line">        while (sqlite3_step(stmt) == SQLITE_ROW)</span><br><span class="line">        &#123;</span><br><span class="line">            int count = sqlite3_column_count(stmt);</span><br><span class="line">            if (count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithCapacity:count];</span><br><span class="line">                for (int i = 0; i &lt; count; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    // 获取列的名字</span><br><span class="line">                    NSString *columnName = [NSString stringWithUTF8String:sqlite3_column_name(stmt, i)];</span><br><span class="line">                    </span><br><span class="line">                    // 获取列的数据类型，在sqlite3.h文件中的第4369行定义为：</span><br><span class="line">                    /*</span><br><span class="line">                    #define SQLITE_INTEGER  1</span><br><span class="line">                    #define SQLITE_FLOAT    2</span><br><span class="line">                    #define SQLITE_BLOB     4</span><br><span class="line">                    #define SQLITE_NULL     5</span><br><span class="line">                    #ifdef SQLITE_TEXT</span><br><span class="line">                    # undef SQLITE_TEXT</span><br><span class="line">                    #else</span><br><span class="line">                    # define SQLITE_TEXT     3</span><br><span class="line">                    #endif</span><br><span class="line">                    #define SQLITE3_TEXT     3</span><br><span class="line">                    */</span><br><span class="line">                    int columnType = sqlite3_column_type(stmt, i);</span><br><span class="line">                    </span><br><span class="line">                    // 声明一个值容器</span><br><span class="line">                    id value = nil;</span><br><span class="line">                    </span><br><span class="line">                    if (columnType == SQLITE_INTEGER) &#123;</span><br><span class="line">                        value = [NSNumber numberWithLongLong:sqlite3_column_int64(stmt, i)];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (columnType == SQLITE_FLOAT)</span><br><span class="line">                    &#123;</span><br><span class="line">                        value = [NSNumber numberWithDouble:sqlite3_column_double(stmt, i)];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (columnType == SQLITE_BLOB)</span><br><span class="line">                    &#123;</span><br><span class="line">                        const char *dataBuffer = sqlite3_column_blob(stmt, i);</span><br><span class="line">                        int dataSize = sqlite3_column_bytes(stmt, i);</span><br><span class="line">                        if (dataBuffer != NULL) &#123;</span><br><span class="line">                            value = [NSData dataWithBytes:(const void *)dataBuffer length:(NSUInteger)dataSize];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        const char* c = (const char*)sqlite3_column_text(stmt, i);</span><br><span class="line">                        if (c != NULL) &#123;</span><br><span class="line">                            value = [NSString stringWithUTF8String:c];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (value) &#123;</span><br><span class="line">                        [dic setValue:value forKey:columnName];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        [dic setValue:[NSNull null] forKey:columnName];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                [array addObject:[dic copy]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (array.count &gt; 0) &#123;</span><br><span class="line">            return [array copy];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在取得表中，具体的对象时，由于 sqlite3 中没有提供相应的函数直接获取整体，所以需要每个字段的获取。而在获取时，需要根据具体的数据类型判断来初始化对象。在 sqlite3.h 中将数据类型归结为：INTEGER、FLOAT、BLOB、TEXT 四种，所以分别判断数据类型，并使用相应的获取方法从 stmt 中获取值。</p><p>当数据需要修改时，需要用到 SQL 的 <code>update</code> 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)updateWithFactor:(NSString *)factor inTable:(NSString *)table</span><br><span class="line">&#123;</span><br><span class="line">    if (![self open]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;update %@ set %@&quot;, table, factor];</span><br><span class="line">    char *msg = NULL;</span><br><span class="line">    int rt = sqlite3_exec(_database, [sql UTF8String], NULL, NULL, &amp;msg);</span><br><span class="line">    </span><br><span class="line">    return rt == SQLITE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的封装，我们尽可能的让使用库的人员少写数据库语句。但是这样做，实际上降低了库的灵活性，应对简单的场景都比较捉襟见肘，复杂就更别说了。</p><h2 id="SQLite的缺点"><a href="#SQLite的缺点" class="headerlink" title="SQLite的缺点"></a>SQLite的缺点</h2><p>上一节的例子中，我们看到了想要直接使用 sqlite 数据库，几乎都是 c 语言，一定程度上增加了开发难度。并且我所制作的简单库适用性还很片面，或许只能在我所在的项目中使用。另外真实的数据库操作还包括：事务、多线程安全等。</p><p>如果要实现事务的话，那么在执行 BEGIN、COMMIT、ROLLBACK 操作需要用到以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_exec(_database, &quot;BEGIN&quot;, NULL, NULL, &amp;msg)</span><br><span class="line">sqlite3_exec(_database, &quot;COMMIT&quot;, NULL, NULL, &amp;msg)</span><br><span class="line">sqlite3_exec(_database, &quot;ROLLBACK&quot;, NULL, NULL, &amp;msg)</span><br></pre></td></tr></table></figure><p>对于多线程安全，在提交操作 UPDATE、INSERT、SELECT 等操作时，需要自定义一个串行队列，按照入栈顺序依次执行。方案如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-a27081fd838718b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程安全"></p><p>方案是现成的，只是实现问题而已。</p><p>上面分析的无疑会给开发增加难度。所以需要有这么一个轮子来帮我们做这些工作，而 FMDB 正是这样的一个库。</p><h2 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h2><p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> 是一套基于 SQLite 的数据库框架，它将原有的 c 语言库进行了面向对象的封装，并且通过串行队列保证了线程的安全。但是由于它使用 Objective-C 封装的，所以丧失了 SQLite 原本的跨平台特点，而只能在 iOS 中使用。</p><p>在 FMDB 中提供了4个类：</p><ol><li><code>FMDatabase</code>，表示一个单独的 SQLite 数据库实例。通过封装，可以使用面向对象的技术对数据库进行增删改查等操作；</li><li><code>FMDatabaseQueue</code>，使用串行队列，实现对多线程的支持；</li><li><code>FMDatabasePool</code>，使用任务池的方式，实现对多线程的支持（官方不推荐：Before using <code>FMDatabasePool</code>, please consider using <code>&lt;FMDatabaseQueue&gt;</code> instead.）；</li><li><code>FMResultSet</code>，数据库查询结果对象。</li></ol><p>和上章节提到的实现数据库线程安全的方案相同，<code>FMDatabaseQueue</code> 也是将所有的操作 block 都放到了一个 Serial 的串行队列中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</span><br><span class="line">dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</span><br></pre></td></tr></table></figure><p>第一句代码其实就是新建一个串行队列 <code>_queue</code> 由于执行数据库操作。防止多线程操作数据库导致死锁的精髓就在第二句。<code>dispatch_queue_set_specific</code> 函数的作用是将 <code>(__bridge void *)self</code> 和 <code>_queue</code> 关联起来，而为什么要这样关联，请看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * A key used to associate the FMDatabaseQueue object with the dispatch_queue_t it uses.</span><br><span class="line"> * This in turn is used for deadlock detection by seeing if inDatabase: is called on</span><br><span class="line"> * the queue&apos;s dispatch queue, which should not happen and causes a deadlock.</span><br><span class="line"> */</span><br><span class="line">static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</span><br><span class="line"></span><br><span class="line">- (void)inDatabase:(void (^)(FMDatabase *db))block &#123;</span><br><span class="line">#ifndef NDEBUG</span><br><span class="line">    /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue</span><br><span class="line">     * and then check it against self to make sure we&apos;re not about to deadlock. */</span><br><span class="line">    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">    assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    FMDBRetain(self);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(_queue, ^() &#123;</span><br><span class="line">        </span><br><span class="line">        FMDatabase *db = [self database];</span><br><span class="line">        block(db);</span><br><span class="line">        </span><br><span class="line">        if ([db hasOpenResultSets]) &#123;</span><br><span class="line">            NSLog(@&quot;Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]&quot;);</span><br><span class="line">            </span><br><span class="line">#if defined(DEBUG) &amp;&amp; DEBUG</span><br><span class="line">            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@&quot;_openResultSets&quot;] copy]);</span><br><span class="line">            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) &#123;</span><br><span class="line">                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];</span><br><span class="line">                NSLog(@&quot;query: &apos;%@&apos;&quot;, [rs query]);</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏定义 <code>NDEBUG</code> 的作用是将断言宏 <code>assert</code> 替换为无意义的代码（<a href="https://dhoerl.wordpress.com/tag/xcode-configurations/" target="_blank" rel="noopener">参考文档</a>）。</p><p>在 <code>inDatabase</code> 中，首先获取了当前的队列所关联的对象，如果当前队列通过 <code>kDispatchQueueSpecificKey</code> 关联了对象，那么获取到的就是该对象，否则返回 nil 。通过下面的例子来说明一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const void * const kDispatchQueueSpecificKey = &amp;kDispatchQueueSpecificKey;</span><br><span class="line"></span><br><span class="line">NSObject *queueAssociateObject = [[NSObject alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;SQLite.demo.queue&quot;, NULL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_set_specific(queue, kDispatchQueueSpecificKey, (__bridge void*)queueAssociateObject, NULL);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, queueAssociateObject);</span><br><span class="line"></span><br><span class="line">id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">NSLog(@&quot;%@&quot;, object);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">    NSLog(@&quot;%@&quot;, object);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDemo[28346:1421335] &lt;NSObject: 0x102803100&gt;</span><br><span class="line">SQLiteDemo[28346:1421335] (null)</span><br><span class="line">SQLiteDemo[28346:1421335] &lt;NSObject: 0x102803100&gt;</span><br></pre></td></tr></table></figure><p>可以看到，第二次输出的是获取 <code>dispatch_main_queue</code> 通过 <code>kDispatchQueueSpecificKey</code> 关联的对象，打印结果为 null ，因为 <code>queueAssociateObject</code> 是关联在 <code>queue</code> 上的，所以第三次打印就正确了。换句话说，通过 <code>dispatch_queue_set_specific</code> 能建立一个映射关系。</p><p>回到 <code>inDatabase</code> 中，当回去到当前队列所关联的对象后，如果关联对象和 <code>self</code> 相等，那么证明 <code>inDatabase</code> 也是在 <code>_queue</code> 中执行的，这就会造成多线程的死锁问题。所以使用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(currentSyncQueue != self &amp;&amp; &quot;inDatabase: was called reentrantly on the same queue, which would lead to a deadlock&quot;);</span><br></pre></td></tr></table></figure><p>在开发阶段判断死锁，从而实现了线程安全。下面再举个例子说明下这里的死锁情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_set_specific(queue, kDispatchQueueSpecificKey, (__bridge void*)queueAssociateObject, NULL);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, queueAssociateObject);</span><br><span class="line"></span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">            </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">         NSLog(@&quot;%@&quot;, object);</span><br><span class="line">    &#125;);</span><br><span class="line">            </span><br><span class="line">    id object = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);</span><br><span class="line">     NSLog(@&quot;%@&quot;, object);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到第二个 <code>dispatch_sync</code> 的时候就死锁了。</p><p>之所以要加上这样的判断是因为对数据库的访问可能是随机的、不同线程间（也可能是不同的网络回调等）的。内置一个 Serial 队列后，<code>FMDatabaseQueue</code> 并通过技巧判断后就变成线程安全了，所有的数据库访问都是同步执行。</p><p>接下来看看它对事务的支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginTransaction:(BOOL)useDeferred withBlock:(void (^)(FMDatabase *db, BOOL *rollback))block &#123;</span><br><span class="line">    FMDBRetain(self);</span><br><span class="line">    dispatch_sync(_queue, ^() &#123; </span><br><span class="line">        </span><br><span class="line">        BOOL shouldRollback = NO;</span><br><span class="line">        </span><br><span class="line">        if (useDeferred) &#123;</span><br><span class="line">            [[self database] beginDeferredTransaction];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [[self database] beginTransaction];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        block([self database], &amp;shouldRollback);</span><br><span class="line">        </span><br><span class="line">        if (shouldRollback) &#123;</span><br><span class="line">            [[self database] rollback];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            [[self database] commit];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    FMDBRelease(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到， FMDB 中的事务支持了延迟，当 <code>useDeferred</code> 为 <code>true</code> 时，使用事务不会立即获取锁，此时其他的线程货进程依然可以使用事务操作数据库，而数据库的上锁会直到需要锁的时候由 <code>sqlite3</code> 库本身添加。而如果我们不这样的搞笑操作时，它提供了友好的 API 操作，只需要将该字段传入 <code>false</code> 就能立即获取到排它锁（EXCLUSIVE），从而禁止其他任何情况对数据库的访问。</p><p>不知道为什么 FMDB 没有支持 IMMEDIATE 来实现 SHARED 锁？是因为目前绝大多数 App 都不没有这种应用场景？</p><p>FMDB 建立在 sqlite 3.7 版本之上，利用 <a href="https://sqlite.org/lang_savepoint.html" target="_blank" rel="noopener">SAVEPOINT</a> 来实现更精确的 ROLLBACK ，源码在 <code>FMDatabase.h</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)startSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</span><br><span class="line">    NSParameterAssert(name);</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)];</span><br><span class="line">    </span><br><span class="line">    return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];</span><br><span class="line">#else</span><br><span class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</span><br><span class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)releaseSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</span><br><span class="line">    NSParameterAssert(name);</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;release savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)];</span><br><span class="line"></span><br><span class="line">    return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];</span><br><span class="line">#else</span><br><span class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</span><br><span class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)rollbackToSavePointWithName:(NSString*)name error:(NSError**)outErr &#123;</span><br><span class="line">#if SQLITE_VERSION_NUMBER &gt;= 3007000</span><br><span class="line">    NSParameterAssert(name);</span><br><span class="line">    </span><br><span class="line">    NSString *sql = [NSString stringWithFormat:@&quot;rollback transaction to savepoint &apos;%@&apos;;&quot;, FMDBEscapeSavePointName(name)];</span><br><span class="line"></span><br><span class="line">    return [self executeUpdate:sql error:outErr withArgumentsInArray:nil orDictionary:nil orVAList:nil];</span><br><span class="line">#else</span><br><span class="line">    NSString *errorMessage = NSLocalizedString(@&quot;Save point functions require SQLite 3.7&quot;, nil);</span><br><span class="line">    if (self.logsErrors) NSLog(@&quot;%@&quot;, errorMessage);</span><br><span class="line">    return NO;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码对比，发现经过 FMDB 的封装后，数据库的操作更加面向对象化了。而且支持了多线程安全和事务。</p><p>但 FMDB 也并不是完美的，目前我发现由以下几个比较坑的：</p><ol><li>由于查询结果封装在 map 中，所以不能直接获取基础数据类型，都是通过 <code>NSNumber</code> 或 <code>NSValue</code> 包装后的对象；</li><li>如果能将部分常用的 SQL 语句集成到库中，使用一时爽，一直使用一直爽（有点痴人说梦的感觉）；等等。</li></ol><p>看完 <code>FMDatabaseQueue</code> 实现多线程安全和事务后，再来看看 <code>FMDatabasePool</code> 是怎么做的？</p><p>从源码可以看出，<code>Pool</code> 中增加了两个属性：<code>_databaseInPool</code>、<code>_databaseOutPool</code>，用于存放同一个路径对应的数据库抽象对象 <code>FMDatabase</code> 的实体。每次，当执行 <code>inDatabase</code> 方法时，首先从 <code>_databaseInPool</code> 中去获取数据库对象，如果获取到了，那么将起放到 <code>_databaseOutPool</code> 中，如果没有取到，那么考虑初始化一个数据库对象，当数据库通过用户代理设置无需加入到 <code>Pool</code> 中时，直接关闭数据库连接，释放数据库对象不执行数据库操作，当代理方法返回 <code>true</code> 时将其放入到 <code>_databaseOutPool</code> 中管理。</p><p>当然，官方给出了一条建议：</p><blockquote><p>If you really really really know what you’re doing and <code>FMDatabasePool</code> is what you really really need (ie, you’re using a read only database), OK you can use it. But just be careful not to deadlock!<br>ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，我从基础的 <code>SQLite</code> 使用到 <code>FMDB</code> 进行了探讨和研究，不仅仅使用到了数据库的知识：增、删、查、改和锁，还学习到了 <code>FMDB</code> 在解决多线程死锁时使用的技巧，通过 <code>dispatch_queue_set_specific()</code> 函数关联对象和队列，通过对象相等变相推断队列相同，从而避免了线程死锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端的纯在线 App 已经跟不上时代的节奏了，或多或少都会有一些数据需要本地存储。目前在 iOS 上有以下几种方式可供选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;NSUserDefault&lt;/code&gt;，也称偏好设置。用于数据规模小，于业务无关的数据存储；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keychain&lt;/code&gt;，苹果提供的带有可逆加密的存储机制，只要系统不重装，数据都能得到保留，并且支持 iClound 云同步，普遍用于各种存密码的存储和用户唯一标识串等；&lt;/li&gt;
&lt;li&gt;文件存储：&lt;ul&gt;
&lt;li&gt;Plist 文件，也称属性列表。结构化较好或需要方便查询的数据可以选择；&lt;/li&gt;
&lt;li&gt;Archive ，也叫归档/解档。如果需要直接对象化数据时使用，但是由于归档或解档时需要对对象序列化，耗时较多；&lt;/li&gt;
&lt;li&gt;一般文件存储，由于文件在在读写时耗时，所以通常用在量比较小的数据上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CoreData，苹果官推的数据存储框架，笔者没使用过，这里有个文章可以看看：&lt;a href=&quot;http://blog.devtang.com/2016/08/04/i-do-not-like-core-data/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;我为什么不喜欢 Core Data&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;数据库存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;说到数据库存储，目前流行的有： &lt;a href=&quot;https://www.sqlite.org/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQLite&lt;/a&gt;、&lt;a href=&quot;https://realm.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Realm&lt;/a&gt; 等方式在移动端使用。并且它们都有轻量级、跨平台的特点，而今天的主角是 SQLite 数据库。下面将从两方面来探讨下：&lt;a href=&quot;#SQLite&quot;&gt;SQLite&lt;/a&gt;、&lt;a href=&quot;#FMDB&quot;&gt;FMDB&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发笔记" scheme="https://qiancaox.github.io/categories/iOS-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>对 CoreAnimation 进行封装，实现链式调用</title>
    <link href="https://qiancaox.github.io/2019/04/18/%E5%AF%B9%20CoreAnimation%20%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
    <id>https://qiancaox.github.io/2019/04/18/对 CoreAnimation 进行封装，实现链式调用/</id>
    <published>2019-04-18T13:11:03.313Z</published>
    <updated>2019-04-18T13:11:03.313Z</updated>
    
    <content type="html"><![CDATA[<p>动画在 iOS 开发中可谓是见惯不怪了，实现动画的方式多种多样。你可以使用 facebook 的 <a href="https://github.com/facebook/pop" target="_blank" rel="noopener">pop</a>，基于 <code>CADisplayLink</code> 自行实现，也可以基于系统提供的 api 进行开发。</p><p>这篇文章是基于系统的 CoreAnimation 库进行二次封装，实现动画的链式调用。由于最近比较痴迷于 Swift ,所以代码使用该语言实现，但是思路是相同的，喜欢的可以自己实现一套 Objective-C 的链式动画库。</p><a id="more"></a><h2 id="为什么我要做这个库"><a href="#为什么我要做这个库" class="headerlink" title="为什么我要做这个库"></a>为什么我要做这个库</h2><p>正如开篇所说，动画的使用太多了，而 CA 框架的动画实现太过于呆板，而且巨繁琐。如果一个项目只有少数的动画效果需要实现，这样使用问题不大，但是大量动画着实虐心。</p><p>既然无法减少动画的开发，那么有没有什么办法让动画的实现不再那么无聊甚至无趣（至少对简单动画而言）。所以，考虑到这点，我就动手做了一个能够实现简单动画的链式封装。当然，能力有限，目前只是针对 Basic 和 Group 两种动画的链式封装。</p><h2 id="我是如何设计这个库的"><a href="#我是如何设计这个库的" class="headerlink" title="我是如何设计这个库的"></a>我是如何设计这个库的</h2><p><img src="https://upload-images.jianshu.io/upload_images/1858049-67c456a499fc3780.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YSChainAnimator"></p><p>如图所示，我通过一个中间类来统一管理所有的动画对象，当触发 <code>run</code> 时动画开始执行。通过这样的设计，我将整个库需要完成的功能以及提供的接口方法都一并用接口的方式实现了，具体我们在下一章节中来看看实现上的细节。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>初始化方法提供了两个，一种是直接使用 layer 初始化，另外一种是使用 view 初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private weak var layer: CALayer!</span><br><span class="line"></span><br><span class="line">init(layer: CALayer) &#123;</span><br><span class="line">    self.layer = layer</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">convenience init(view: UIView) &#123;</span><br><span class="line">    self.init(layer: view.layer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而动画执行必须要等到 <code>run</code> 方法触发后才能执行，所以需要一个集合来存放已经初始化了的动画对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private var animations: [(key: String, anim: CAAnimation)] = []</span><br></pre></td></tr></table></figure><p>动画对象的存储使用了数组嵌套元组的结构，能够方便我们在寻找对应的动画对象时效率较高，存储意义也明确。而在关联动画的“寻址 <code>key</code>”时，为了方便使用方使用，在使用者不想绞尽脑汁想 key 时，我也提供了默认的 key 使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private func _animKey(_ key: String? = nil) -&gt; String &#123;</span><br><span class="line">    return key ?? &quot;com.YSChainAnimator.anim.count_\(animations.count)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你需要添加一个动画对象时，内部实现一个公用的方法实现添加动画到动画管理容器中，后续直接调用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func _add(_ key: String? = nil, anim handler: () -&gt; CAAnimation) -&gt; Self &#123;</span><br><span class="line">    animations.append((key: _animKey(key), anim: handler()))</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过闭包的方式，将动画的初始化放由使用者决定，一定程度上提高了库的灵活性。私有方法介绍后，看看公共接口是如何实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func anim(_ keyPath: String, key: String? = nil) -&gt; Self &#123;</span><br><span class="line">    return _add(key) &#123;</span><br><span class="line">        let anim = CABasicAnimation(keyPath: keyPath)</span><br><span class="line">        anim.duration = 1.0</span><br><span class="line">        return anim</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@discardableResult</span><br><span class="line">func group() -&gt; Self &#123;</span><br><span class="line">    if animations.count == 0 &#123;</span><br><span class="line">        print(&quot;Group animation ocurred error, because there are any animation in animator.&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        let _animations = animations</span><br><span class="line">        animations.removeAll()</span><br><span class="line">        _add(&quot;com.YSChainAnimator.anim.group.count_\(animations.count)&quot;) &#123; () -&gt; CAAnimation in</span><br><span class="line">            let group = CAAnimationGroup()</span><br><span class="line">            group.animations = _animations.compactMap &#123; $0.anim &#125;</span><br><span class="line">            return group</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">func run() &#123;</span><br><span class="line">    for animate in animations &#123;</span><br><span class="line">        layer.add(animate.anim, forKey: animate.key)</span><br><span class="line">    &#125;</span><br><span class="line">    animations.removeAll()</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">@discardableResult</span><br><span class="line">func modify&lt;T: CAAnimation&gt;(anim handler:(T?) -&gt; Void) -&gt; Self  &#123;</span><br><span class="line">    handler(animations.last?.anim as? T)</span><br><span class="line">    return self</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的动画默认动画时间为1s；<code>group</code> 是将之前所有加的动画全部都使用组动画进行包装。为了方便对更精确的属性进行修改，提供一个 <code>modify</code> 方法，另外如果还有更详细的动画属性需要设置，使用方也可以自己调用方法进行设置。精确的方法实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line">func duration(_ d: CFTimeInterval = 1.0) -&gt; Self &#123;</span><br><span class="line">    return modify &#123; $0?.duration = d &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">@discardableResult</span><br><span class="line">func from(_ v: Any?) -&gt; Self &#123;</span><br><span class="line">    return modify &#123;</span><br><span class="line">        if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123;</span><br><span class="line">            print(&quot;Modify last animation `fromValue` ocurred error, because it&apos;s an group animation.&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ($0 as! CABasicAnimation).fromValue = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@discardableResult</span><br><span class="line">func to(_ v: Any?) -&gt; Self &#123;</span><br><span class="line">    return modify &#123;</span><br><span class="line">        if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123;</span><br><span class="line">            print(&quot;Modify last animation `toValue` ocurred error, because it&apos;s an group animation.&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ($0 as! CABasicAnimation).toValue = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">@discardableResult</span><br><span class="line">func by(_ v: Any?) -&gt; Self &#123;</span><br><span class="line">    return modify &#123;</span><br><span class="line">        if $0?.isKind(of: CAAnimationGroup.self) ?? false &#123;</span><br><span class="line">            print(&quot;Modify last animation `byValue` ocurred error, because it&apos;s an group animation.&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ($0 as! CABasicAnimation).byValue = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">@discardableResult</span><br><span class="line">func timing(_ v: CAMediaTimingFunction) -&gt; Self &#123;</span><br><span class="line">    return modify &#123; $0?.timingFunction = v &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">@discardableResult</span><br><span class="line">func hold() -&gt; Self &#123;</span><br><span class="line">    return modify &#123;</span><br><span class="line">#if swift(&gt;=4.2)</span><br><span class="line">        $0?.fillMode = CAMediaTimingFillMode.forwards</span><br><span class="line">#else</span><br><span class="line">        $0?.fillMode = kCAFillModeForwards</span><br><span class="line">#endif</span><br><span class="line">        $0?.isRemovedOnCompletion = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实现相对比较简单，都是通过调用 <code>modify</code> 方法实现的，当然如果这些便捷方法不满足需求，使用方还可以自己调用该方法实现。<code>hold</code> 方法是常规的对动画完成后的停留属性的包装。这里就是 modal 和 presentation 的区别了，设计到比较底层的 CoreAnimation 的知识，这里做一个引子，后续如果有时间，再来仔细研究该框架。</p><p>为了更贴切的监听动画的状态，还需要增加对动画开始和结束的回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">extension YSChainAnimator &#123;</span><br><span class="line">    </span><br><span class="line">    private class AnimationDelegate: NSObject, CAAnimationDelegate &#123;</span><br><span class="line">        </span><br><span class="line">        private let begin: AnimatingClosure?</span><br><span class="line">        private let end: AnimatingClosure?</span><br><span class="line">        </span><br><span class="line">        init(begin: AnimatingClosure?, end: AnimatingClosure?) &#123;</span><br><span class="line">            self.begin = begin</span><br><span class="line">            self.end = end</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        func animationDidStart(_ anim: CAAnimation) &#123;</span><br><span class="line">            begin?(anim)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123;</span><br><span class="line">            end?(anim)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @discardableResult</span><br><span class="line">    func animating(begin: AnimatingClosure?, end: AnimatingClosure?) -&gt; Self &#123;</span><br><span class="line">        animations.last?.anim.delegate = AnimationDelegate(begin: begin, end: end)</span><br><span class="line">        return self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方，使用一个私有类来实现对 CoreAnimation 的动画代理方法的实现，进而可以统一管理回调。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章是对开发中繁琐功能的简化封装，在封装过程中设计到了“工厂设计模式”的体现。通过使用 Swift 来实现，一方面学习了新的语言。另外，感到这门语言着实让人吃惊，简洁但又明确，相信在不久的将来（等它比较稳定的将来）应该能够替换 Objective-C 。使用先设计，再开发的步骤有效的提高了编码的质量，以后应该多使用这样的方式开发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动画在 iOS 开发中可谓是见惯不怪了，实现动画的方式多种多样。你可以使用 facebook 的 &lt;a href=&quot;https://github.com/facebook/pop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pop&lt;/a&gt;，基于 &lt;code&gt;CADisplayLink&lt;/code&gt; 自行实现，也可以基于系统提供的 api 进行开发。&lt;/p&gt;
&lt;p&gt;这篇文章是基于系统的 CoreAnimation 库进行二次封装，实现动画的链式调用。由于最近比较痴迷于 Swift ,所以代码使用该语言实现，但是思路是相同的，喜欢的可以自己实现一套 Objective-C 的链式动画库。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发笔记" scheme="https://qiancaox.github.io/categories/iOS-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>当 MVVM 邂逅 RxSwift</title>
    <link href="https://qiancaox.github.io/2019/04/18/%E5%BD%93%20MVVM%20%E9%82%82%E9%80%85%20RxSwift/"/>
    <id>https://qiancaox.github.io/2019/04/18/当 MVVM 邂逅 RxSwift/</id>
    <published>2019-04-18T13:01:00.056Z</published>
    <updated>2019-04-18T13:11:22.515Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM</a> 起源于2005年，由微软的架构师 John Gossman 提出的一种架构模式，并在 <a href="https://en.wikipedia.org/wiki/Windows_Presentation_Foundation" target="_blank" rel="noopener">WPF</a> 和 <a href="https://en.wikipedia.org/wiki/Microsoft_Silverlight" target="_blank" rel="noopener">Silverlight</a> 中使用。它是 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener">MVC</a> 的一种衍生架构，通过“绑定”机制将 Controller 中的业务代码脱离出来，从而促进了 UI 层与逻辑代码的分离。</p><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift</a> 是 <a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> 的 Swift 版本，扩展了<a href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">观察者模式</a>，是一套基于异步事件的响应式编程框架。</p><a id="more"></a><p>这两个神奇的技术碰撞到一起会有什么样的火花呢？下面，我将从以下几方面来简述我在使用它们时的一些感悟（纯属个人理解）：<a href="#MVC">MVC</a>、<a href="#MVVM">MVVM</a>、<a href="#RxSwift">RxSwift</a>、<a href="#MVVM邂逅RxSwift">MVVM邂逅RxSwift</a></p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC 可以说是一套最经典的客户端开发架构，同时苹果官方也是极力推崇的架构模式。它将项目分为：Model、View、Controller 三个层级，它们的关系如下图所示：</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2058564545,654273587&amp;fm=26&amp;gp=0.jpg" alt="图解MVC"></p><p>上图清晰的展示的它们三者的关系，Model 代表数据，View 带边视图，Controller 则负责帮助它们建立关系：</p><ol><li>Model：指模型，数据的抽象，表示业务规则；</li><li>View：用户界面，展示模型返回的数据，接受并传递用户交互；</li><li>Controller：响应用户交互，并映射为用户行为，从而修改模型数据指示界面更新。</li></ol><p>Controller ，通过 data source 和 delegate 来更新视图，通过 outlet 持有视图。View 则通过 action-target 的方式传递用户事件。同时 Controller 接收到 View 传递的事件后直接修改持有的 Model ，引发 Model 的观察者（KVO）或通知机制告知 Controller ，data source 需要工作来更改 View。</p><p>这样的工作方式看起来井井有条，实际上却很难有效得将这三者区分开来，特别是苹果还设计了 <code>UIViewController</code> ，这就更加难于区分 Controller 和 View 了。在我看来苹果设计的 <code>UIViewController</code> 只是为视图提供一个容器，也就是说 Controller 中的 view 属性应该叫做 <strong>view container</strong> 更为贴切。</p><p>另外，由于 View 和 Model 相互独立，导致了 Controller 中的业务代码会随着业务的增加而日益庞大起来，最终导致了 <a href="https://twitter.com/Colin_Campbell/status/293167951132098560" target="_blank" rel="noopener">Massive View Controller</a> 的出现，使 Controller 不利于维护。再加上网络层在该框架下也并没有确切的定位，也导致了网络放哪里都不合适的错觉。</p><p><strong>提示：在服务端的开发中，javabean+jsp+servlet，能够很贴切的体现 MVC 架构思想。</strong></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>由于 MVC 在实现时，不易区分各个功能模块的界线和 Controller 过于厚重等问题被暴露后，由微软架构师 John Gossman 在 MVC 的基础上优化衍生，并于2005年提出的 MVVM 则完美的解决了这一问题，促进了 UI 和业务逻辑的分离。</p><p>首先，在 MVVM 中，项目被分为了：Model、View、ViewModel 3个模块：</p><p><img src="http://cc.cocimg.com/api/uploads/20150525/1432542173109354.png" alt="MVC和MVVM对比图"></p><p>通过上图，可以看出，实际上新架构中的 ViewModel 抢去了原来 Controller 的部分工作，从而解决了控制器过于厚重的问题。而它们的关系如下图所示：</p><p><img src="https://objccn.io/images/issues//issue-13/mvvm.png" alt="MVVM关系图"></p><p>我们可以这样理解它的各个模块：</p><ol><li>Model：和 MVC 中的一致，依然表示对数据的抽象，体现了业务的规则；</li><li>ViewModel：新架构增加的中间层，用于管理视图和模型之间的相互影响的因果关系。换句话说：模型的改变可能会影响视图对应的改变，而视图的改变也可能会引发模型作出相应的改动，最初这部分工作是由控制器来做的，现在 MVVM 中则由 ViewModel 来实现，而至于它们之间的相互影响的关系是使用 KVO 还是 Rx 只是具体的实现技术而已，与架构本身并没有关系；</li><li>View：将模型返回的数据用最高可读性的方式表达给用户，响应并传递用户交互；</li></ol><p>我认为这三个模块并不完整，因为项目中有众多的 View 和 ViewModel ，然而它们的关系需要 Controller 来建立，也就是“绑定”，所以还应该补充一点：</p><p><img src="http://cc.cocimg.com/api/uploads/20150525/1432542301497557.gif" alt="MVMCV"></p><ol start="4"><li>Controller：完成 View、ViewMode 二者的关系建立。</li></ol><p>经过这样的演进，最终大量的逻辑代码将被移动到 ViewModel 中，从而 Controller 只需要管理视图以及视图和 ViewModel 之间的绑定关系，达到了更轻量级的控制的目的。同时，无处安放的网络请求也将由 ViewModel 实现，并提供 Command 的接口给 Controller 调用。</p><p>另外，由于 <code>UIViewController</code> 和 <code>UIView</code> 只是不同的组件而已，在苹果的实现中通常都是对应出现的，能看到 View ，那么就一定能找到一个对应的 Controller ，能出现一个 Controller ，也一定能找多至少一个 View ，所以索性就将它们两个看成一个模块，只是递进关系不同，功能存在包含而已。基于这样的考虑，我在项目结构上大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">|          ...          |</span><br><span class="line">|                       |</span><br><span class="line">|         Model         |</span><br><span class="line">|                       |</span><br><span class="line">|         |  /|\        |</span><br><span class="line">|         |   |         |</span><br><span class="line">|        \|/  |         |</span><br><span class="line">|                       |</span><br><span class="line">|       ViewModel       |</span><br><span class="line">|                       |</span><br><span class="line">|         |  /|\        |</span><br><span class="line">|         |   |         |</span><br><span class="line">|        \|/  |         |</span><br><span class="line">|                       |</span><br><span class="line">|   View &amp; Controller   |</span><br><span class="line">|                       |</span><br><span class="line">|          ...          |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>这是一个比较受争议的划分，只是在我看来如果非要严格的区分控制器和视图，在某种情况下会让架构失去灵活性，增加开发难度，不利于实践使用。例如：我要实现一个全局配置的功能，实际上我只需要很少量的视图组件就能完成，这个时候还非得区分 View 和 Controller，反倒没有直接将 <code>UIViewController</code> 即看作控制器又看作视图来的直接，而真正的业务模块的确应该坚持职责单一原则，区分得足够详细，后期维护就能够事半功倍。</p><p>我们再将视线移回到模块职业上。</p><p>MVVM 作为 MVC 的升级版，优化了随着业务的增加导致了 Controller 逐渐臃肿等问题，那么升级过后的模块又是怎么样的职业划分的呢？</p><p>首先，模型做为数据的抽象，它体现了业务的形态，所以模型的实现一定是根据具体业务进行抽象，例如：我们有一个网上的商品交易系统，现在要做商品的买卖需求。在这个需求中，买东西一定需要定位到单一的商品，买家和卖家也一定要形成唯一关系，从而我们在设计 order 模型时，一定就需要有字段能够接受商品的唯一id，卖家的唯一id和买家的唯一id，这样一来，谁要买谁的什么商品的需求就抽象成 order 的模型来体现了！</p><p>所以在我看来，如果模型所做的事情超出了了业务形态的范围，那么就不算是一个优秀的设计。当然，作为数据的载体，它也应该提供相应的数据读写接口，供其他模块调用。（这也是我认为“胖 model”不合理的原因）</p><p>接下来再来看看重头戏：ViewModel。作为 Controller 的小弟，它帮助控制完成了大量的工作，那么那些工作应该由它来做呢？我归纳了以下几点（可能有点片面）：</p><ol><li>使用抽象模型作为载体修改和更新数据。数据作为系统核心价值的体现，用户通过点击、拖拽等操作 View ，通过 ViewModel 来控制模型进而修改数据，一方面这样能够降低核心数据被恶意窜改的风险，另外，对开发者而言，这样的设计能够提高代码的可维护性；</li><li>作为 View 和 Model 之间的桥梁，那么视图的显示逻辑部分应该由 ViewModel 来完成；</li><li>应该具备或持有 Model ，进而能够修改 Model 所代表的数据；</li><li>提供输入和输出接口，方便 Controller 进行绑定调用；</li><li>实现网络请求，并将结果序列化为对应模型。</li><li>其他…</li></ol><p>以上的小点是我在使用中真实所使用到的场景，可能不全面，等遇到的时候再添加吧。</p><p>最后，Controller 作为控制器，应该管理视图容器（也就是自己的 <code>view</code>）的生命周期，生成子视图并放入到视图容器中一并管理，将 ViewModel 进行绑定完成特定的业务场景。</p><h2 id="RxSwift"><a href="#RxSwift" class="headerlink" title="RxSwift"></a>RxSwift</h2><p>上面我们有讲到实现 MVVM 无论采用 KVO 还是 Rx 都只是实现的技术不同而已，与架构本身没有关系。就 Rx 而言，它本身是一套基于异步事件的响应式框架而已。只是它让 MVVM 的实现更加优美，所以当提到 MVVM 的时候，首先想到的正是 Rx。起初在 RAC 还没有开发出来的时候，MVVM并不是如此火热（至少在 iOS 上是这样的），应该说是 RAC 奠定了 MVVM 的崛起。</p><p>Rx 是 ReactiveX 的缩写，而 ReactiveX 一个基于异步事件的响应式库。它基于观察者模式，支持异步数据和事件序列，通过简单的运算符就能实现对这些序列的订阅、组合、转换等，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。并且它还是一套跨平台的响应式标准，可以到达一处学会到处使用。</p><p>了解了 Rx 是什么之后，我们来了解下它作用是什么（至少在 iOS 中）？下面我们通过具体场景来看看它充当了什么角色：</p><p>(1). 登陆界面中，我们有一个电话号的输入框，要求输入框需要验证电话号是否正确；</p><ul><li>如果我们使用原始技术实现的话，我们可能会使用这几种事件传递的方法处理：<code>delegate</code>、<code>notifinotion</code>、<code>target-action</code>、<code>KVO</code> 等等；</li><li>而 Rx 则统一这些传递方法为信号传递，我们只需要将上面提到的方法全部替换为 <code>rx</code> 所代表的信号链就能完成相同的工作。</li></ul><p>下面是一个简单示例，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#program mark - 原始技术</span><br><span class="line"></span><br><span class="line">textField.addTarget(self, action: #selector(textField(didEditingChanged:)), for: .editingChanged)</span><br><span class="line"></span><br><span class="line">@objc</span><br><span class="line">func textField(didEditingChanged sender: UITextField) &#123;</span><br><span class="line">    var text = sender.text</span><br><span class="line">    if text.valid(type: .phone) &#123;</span><br><span class="line">        // 这里实现通过电话验证的逻辑</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 这里实现未通过电话验证的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">    // 最终逻辑</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#program mark - RxSwift</span><br><span class="line"></span><br><span class="line">textField.rx.text.orEmpty</span><br><span class="line">        .map &#123;</span><br><span class="line">            // 实现电话号验证的逻辑</span><br><span class="line">            $0.valid(.phone)</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            // 最终逻辑</span><br><span class="line">        &#125;</span><br><span class="line">        .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>(2). 在 MVVM 中，为数据绑定提供了更加方便及优美的实现方案。</p><p>当然，它的作用远不止于此，只是就本文的主题而言，我认为这两点已经足够了。</p><p><code>Observables</code> 可以算是 Rx 的核心了，正是它让我们可以对任意异步事件柳进行随意的组合。例如：使用它来作为网络请求的返回值，那么我们从代码的阅读性上就可以看作是一次同步过的过程了，而处理回调只需要订阅它对应的事件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func resume() -&gt; Observable&lt;T&gt; &#123;</span><br><span class="line">    return Observable&lt;T&gt;.create &#123; observer -&gt; Disposable in</span><br><span class="line">        let request = Alamofire.request(self.url,</span><br><span class="line">                                        method: self.method,</span><br><span class="line">                                        parameters: self.parameters,</span><br><span class="line">                                        encoding: self.encoding,</span><br><span class="line">                                        headers: self.headers)</span><br><span class="line">            .responseData &#123;</span><br><span class="line">                if let error = $0.error &#123;</span><br><span class="line">                       observer.onError(error)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if let data = $0.data &#123;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            observer.onNext(try JSONDecoder().decode(T.self, from: data))</span><br><span class="line">                            observer.onCompleted()</span><br><span class="line">                        &#125; catch &#123;</span><br><span class="line">                            observer.onError(error)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Disposables.create &#123;</span><br><span class="line">            request.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样封装后的网络请求更像是同步的操作，因为发送后立即就能得到一个可观察的返回值，而我们只需要监听返回值的相应事件即可，一定程度上简化了异步的思想。</p><p>当然，以上两点只是 Rx 的一些应用而已，它的功能其实远不止于此，更多的内容还有待继续探究。</p><p>其实函数式编程和响应式编程还是有很大区别的，官方文档中式这样描述的：</p><blockquote><p>One main point of difference is that functional reactive programming operates on values that change continuously over time, while ReactiveX operates on discrete values that are emitted over time. </p></blockquote><p>在这里我们就不具体讨论这两者的区别。</p><h2 id="MVVM邂逅RxSwift"><a href="#MVVM邂逅RxSwift" class="headerlink" title="MVVM邂逅RxSwift"></a>MVVM邂逅RxSwift</h2><p>通过上面的三个小章节，我们一起了解了 MVC ，MVVM 以及 RxSwift 。这章节中，我将以“登录”模块作为示例，简示 MVVM 和 RxSwift 会碰撞出什么样的火花。</p><blockquote><p>需求：登录界面中需要填入用户名和密码“登录”按钮才能点击，点击后进行网络请求，成功提示“登录成功”，失败提示具体原因。</p></blockquote><p>在实现 UI 时，我为了更好的区分 Controller 和 View，我将用户名输入框、密码输入框以及按钮放在了单独的 <code>SignContentScrollView</code> 中，并将这三个空间作为公用接口暴露出来，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignContentScrollView</span>: <span class="title">UIScrollView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> panguLogoImageView: <span class="type">UIImageView</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> titleLabel: <span class="type">UILabel</span>!</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> inputContainer: <span class="type">UIView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> usernameTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>!</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> signButton: <span class="type">UIButton</span>!</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> forgetButton: <span class="type">UIButton</span>!</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>View 层算是解决了，接下来看看 ViewModel 应该如何设计？</p><p>ViewModel 作为视图和模型的桥梁，它不仅能够修改或获取模型，还能够响应用户交互和跟新用户界面，我更倾向于将它理解为一座“工厂”，用户界面给它提供“原材料”，经过加工后输出形成可直接使用的产品，这里的加工就是具体的业务逻辑了。结合 Swift 面向协议的特点，可以抽象一个 <code>ViewModelType</code> 的协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fileprivate struct ViewModelTypeAssociateKey &#123;</span><br><span class="line">    static var disposeBag: String = &quot;disposeBag&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol ViewModelType &#123;</span><br><span class="line">    </span><br><span class="line">    associatedtype Inputs</span><br><span class="line">    associatedtype Outputs</span><br><span class="line">    </span><br><span class="line">    // 用于管理 Observable 的释放，通过协议的扩展直接给予默认值</span><br><span class="line">    var disposeBag: DisposeBag &#123; get &#125;</span><br><span class="line">    </span><br><span class="line">    var inputs: Inputs &#123; get &#125;</span><br><span class="line">    var outputs: Outputs &#123; get &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ViewModelType &#123;</span><br><span class="line">   </span><br><span class="line">    var disposeBag: DisposeBag &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            guard let bag = (objc_getAssociatedObject(self, &amp;ViewModelTypeAssociateKey.disposeBag) as? DisposeBag) else &#123;</span><br><span class="line">                let bag = DisposeBag()</span><br><span class="line">                objc_setAssociatedObject(self, &amp;ViewModelTypeProtocolAssociateKey.disposeBag, bag, .OBJC_ASSOCIATION_RETAIN)</span><br><span class="line">                return bag</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return bag</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就有了一个协议来实现对所有 ViewModel 的公共抽象。它具有一个输入和一个输出的结构体，结构体中都会使用 Rx 的 Observable 的对象组成，通过对 Observable 订阅可以实现随时的监听。当落实到具体的登录业务时，<code>ViewModelType</code> 就可以这样实现了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">class SignViewModel: ViewModelType &#123;</span><br><span class="line">    </span><br><span class="line">    struct Inputs &#123;</span><br><span class="line">        let username: AnyObserver&lt;String&gt;</span><br><span class="line">        let password: AnyObserver&lt;String&gt;</span><br><span class="line">        let signCommand: AnyObserver&lt;Void&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct Outputs &#123;</span><br><span class="line">        let validSignSignal: Observable&lt;Bool&gt;</span><br><span class="line">        let signStatusSignal: Observable&lt;RequestStatus&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var inputs: Inputs</span><br><span class="line">    var outputs: Outputs</span><br><span class="line">    </span><br><span class="line">    private let usernameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)</span><br><span class="line">    private let passwordSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)</span><br><span class="line">    private let signCommandSubject = PublishSubject&lt;Void&gt;()</span><br><span class="line">    private let signStatusSubject = PublishSubject&lt;RequestStatus&gt;()</span><br><span class="line">    </span><br><span class="line">    private var loginByNameApi: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let paths = &quot;/&quot;+kSSODirectionPath+&quot;/&quot;+kLoginByNameApi</span><br><span class="line">            guard let api = BaseURLModel.default.SSOApi else &#123;</span><br><span class="line">                return paths</span><br><span class="line">            &#125;</span><br><span class="line">            return api+paths</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private var username: String = &quot;&quot;</span><br><span class="line">    private var passowrd: String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    init() &#123;</span><br><span class="line">        inputs = Inputs(username: usernameSubject.asObserver(), password: passwordSubject.asObserver(), signCommand: signCommandSubject.asObserver())</span><br><span class="line">        outputs = Outputs(validSignSignal: Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125;, signStatusSignal: signStatusSubject)</span><br><span class="line">        </span><br><span class="line">        usernameSubject.asObserver()</span><br><span class="line">            .bind(to: self.usernameBinder)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        passwordSubject.asObserver()</span><br><span class="line">            .bind(to: self.passwordBinder)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">        signCommandSubject</span><br><span class="line">            .subscribe(onNext: &#123; [unowned self] in</span><br><span class="line">                self._respondsToSignIn()</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private func _respondsToSignIn() &#123;</span><br><span class="line">        self.signStatusSubject.onNext(.doing)</span><br><span class="line">        YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi)</span><br><span class="line">            .method(.post)</span><br><span class="line">            .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;])</span><br><span class="line">            .resume()</span><br><span class="line">            .subscribe(onNext: &#123; (response) in</span><br><span class="line">                if response.code == 200 &#123;</span><br><span class="line">                    self.signStatusSubject.onNext(.success)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    self.signStatusSubject.onNext(.failed(message: response.msg))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, onError: &#123; (error) in</span><br><span class="line">                self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;))</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: self.disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension SignViewModel &#123;</span><br><span class="line">    </span><br><span class="line">    private var usernameBinder: Binder&lt;String&gt; &#123;</span><br><span class="line">        return Binder(self) &#123; $0.username = $1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private var passwordBinder: Binder&lt;String&gt; &#123;</span><br><span class="line">        return Binder(self) &#123; $0.passowrd = $1 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usernameSubject</code>、<code>passwordSubject</code>、<code>signCommandSubject</code> 作为 inputs 的桥梁来链接外部参数和内部业务，可以让我们不需要通过方法将 input 和 output 进行转化，Controller 中只需要将输入信号和 inputs 中对应的信号绑定，内部就能通过桥梁信号监听相应的变化。</p><p>在 extension 中，通过数据绑定，将 <code>usernameSubject</code> 和 <code>passwordSubject</code> 的改变值绑定至 <code>username</code> 和 <code>password</code> 中，就是用户的交互改变数据模型的操作，网络请求时就能直接使用正确的值作为参数进行传递，绑定代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">usernameSubject.asObserver()</span><br><span class="line">            .bind(to: self.usernameBinder)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">        </span><br><span class="line">passwordSubject.asObserver()</span><br><span class="line">            .bind(to: self.passwordBinder)</span><br><span class="line">            .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>登录按钮的验证通过对 <code>usernameSubject</code>、<code>passwordSubject</code> 的组合，验证用户名和密码是否合规，最终转化为 <code>Observable&lt;Bool&gt;</code> 的对象，供按钮的 <code>isEnable</code> 直接绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Bool&gt;.combineLatest(usernameSubject, passwordSubject) &#123; $0.count &gt; 0 &amp;&amp; $1.count &gt; 0 &#125;</span><br></pre></td></tr></table></figure><p>登录的状态也通过 <code>let signStatusSignal: Observable&lt;RequestStatus&gt;</code> 提供外部接口，直接观察状态的改变实现成功或失败的提示。（<strong>注：我认为 Controller 做页面的跳转和各种弹窗是必要的工作，所以我将这些放在控制器中做。</strong>）</p><p>最后，当按钮点击后，通过 <code>signCommand</code> 将按钮点击事件传递进来，内部通过订阅取得对应事件并发送网络请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private func _respondsToSignIn() &#123;</span><br><span class="line">    self.signStatusSubject.onNext(.doing)</span><br><span class="line">    YSNetWorking&lt;BaseModel&lt;SignDataModel&gt;&gt;(url: loginByNameApi)</span><br><span class="line">        .method(.post)</span><br><span class="line">        .parameters([&quot;name&quot;: self.username, &quot;password&quot;: self.passowrd, &quot;systemCode&quot;: &quot;ISCC_MOBILE&quot;])</span><br><span class="line">        .resume()</span><br><span class="line">        .subscribe(onNext: &#123; (response) in</span><br><span class="line">            if response.code == 200 &#123;</span><br><span class="line">                self.signStatusSubject.onNext(.success)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                self.signStatusSubject.onNext(.failed(message: response.msg))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, onError: &#123; (error) in</span><br><span class="line">            self.signStatusSubject.onNext(.failed(message: &quot;网络似乎发生了错误!&quot;))</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: self.disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我提一句，得益于 Swift 的范型特点，我们做网络请求时可以取得准确的数据模型。</p><p>由于 Swift 是一门数据严谨的语言，所以在模型设计上就不会想 Objective-C 一样那么灵活了。这里我通过示例简单的展示下我遇到的坑，及解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typealias ModelType = Codable &amp; DescriptionDebugable</span><br><span class="line"></span><br><span class="line">struct BaseModel&lt;T: ModelType&gt;: ModelType &#123;</span><br><span class="line">    var code: Int</span><br><span class="line">    var msg: String</span><br><span class="line">    var success: Bool</span><br><span class="line">    var data: DataWithStringType&lt;T&gt;!</span><br><span class="line">    var progressTask: ProgressTask?</span><br><span class="line">    var errors: [ErrorModel]?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，我所在的项目中 data 字段是所有的有用字段的集合。坑就在这里，当请求正确无误时，data 字段是正确的数据结构，而当请求错误时，服务端将 data 字段设置为一个字符串了，而在 Swift 中，数据类型是唯一确定的，我们不能将 data 字段即设置为一个数据结构又设置为一个字符串。而解决办法就是 – 转化，所以增加了一个 <code>DataWithStringType</code> 的模型，用于判断当前值是否为结构体，如果是，那么就归档到 <code>entity</code> 中，否则就归档到 <code>string</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct DataWithStringType&lt;T: ModelType&gt;: ModelType &#123;</span><br><span class="line">    </span><br><span class="line">    var string: String?</span><br><span class="line">    var entity: T?</span><br><span class="line">    </span><br><span class="line">    init(from decoder: Decoder) throws &#123;</span><br><span class="line">        let singleValueContainer = try decoder.singleValueContainer()</span><br><span class="line">        </span><br><span class="line">        if let stringValue = try? singleValueContainer.decode(String.self)  &#123;</span><br><span class="line">            string = stringValue</span><br><span class="line">        &#125; else if let entityValue = try? singleValueContainer.decode(T.self) &#123;</span><br><span class="line">            entity = entityValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有的准备工作完成后，来看看 Controller 是如何将 ViewModel 和 View 绑定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func bindingViewModel() &#123;</span><br><span class="line">    scrollView.usernameTextField.rx.text.orEmpty</span><br><span class="line">        .bind(to: signVm.inputs.username)</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br><span class="line">        </span><br><span class="line">    scrollView.passwordTextField.rx.text.orEmpty</span><br><span class="line">        .bind(to: signVm.inputs.password)</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br><span class="line">        </span><br><span class="line">    scrollView.signButton.rx.tap</span><br><span class="line">        .bind(to: signVm.inputs.signCommand)</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br><span class="line">        </span><br><span class="line">    signVm.outputs.validSignSignal</span><br><span class="line">        .bind(to: scrollView.signButton.rx.isEnabled)</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br><span class="line">        </span><br><span class="line">    signVm.outputs.signStatusSignal</span><br><span class="line">        .subscribe &#123; [unowned self] in</span><br><span class="line">            self.view.endEditing(false)</span><br><span class="line">            switch $0.element! &#123;</span><br><span class="line">            case .doing:</span><br><span class="line">                self.view.makeActivityWithText(&quot;正在登陆&quot;, userInteraction: false)</span><br><span class="line">            case .success:</span><br><span class="line">                self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activitysuccess&quot;), text: &quot;登陆成功&quot;)</span><br><span class="line">            case let .failed(message):</span><br><span class="line">                self.view.updateActivityWithImage(UIImage(named: &quot;icon-pangu-activityerror&quot;), text: message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样整体看起来，代码的模块性十分的良好。vm 甚至可以单独拿出来进行测试。当内部的业务逻辑需要更改时，几乎可以只动 vm 中的代码就能实现变更。并且在响应上，由于是绑定关系，那么逻辑链路还是相对明显的。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollView.passwordTextField.rx.text.orEmpty</span><br><span class="line">        .bind(to: signVm.inputs.password)</span><br><span class="line">        .disposed(by: signVm.disposeBag)</span><br></pre></td></tr></table></figure><p>将密码的输入绑定到 vm 的 <code>username</code>，而该对象通过 <code>passwordSubject</code>转接到 vm 中执行相应业务逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这篇文章中，通过在真实的项目中使用 Rx 和 MVVM 实现“登录”的需求来学习这二者。我认为重点是对于 vm 的设计和 Controller 如何进行数据绑定的。另外，至于 MVVM 中每个模块应该干什么，还是任重道远啊。</p><p>博文推荐：</p><ul><li><a href="https://blog.csdn.net/zuiyingong6567/article/details/80150834" target="_blank" rel="noopener">深入理解MVC</a></li><li><a href="http://www.cocoachina.com/ios/20170612/19500.html" target="_blank" rel="noopener">iOS 关于MVC和MVVM设计模式的那些事</a></li><li><a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">iOS应用架构谈 view层的组织和调用方案</a></li><li><a href="https://objccn.io/issue-13-1/" target="_blank" rel="noopener">MVVM 介绍</a></li><li><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">RxSwift + MVVM: how to feed ViewModels</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM&lt;/a&gt; 起源于2005年，由微软的架构师 John Gossman 提出的一种架构模式，并在 &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Presentation_Foundation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WPF&lt;/a&gt; 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_Silverlight&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Silverlight&lt;/a&gt; 中使用。它是 &lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVC&lt;/a&gt; 的一种衍生架构，通过“绑定”机制将 Controller 中的业务代码脱离出来，从而促进了 UI 层与逻辑代码的分离。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://beeth0ven.github.io/RxSwift-Chinese-Documentation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxSwift&lt;/a&gt; 是 &lt;a href=&quot;http://reactivex.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactiveX&lt;/a&gt; 的 Swift 版本，扩展了&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;观察者模式&lt;/a&gt;，是一套基于异步事件的响应式编程框架。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发笔记" scheme="https://qiancaox.github.io/categories/iOS-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>从 WWDC 2018 220 Session 窥探 Auto Layout</title>
    <link href="https://qiancaox.github.io/2019/03/28/%E4%BB%8E%20WWDC%202018%20220%20Session%20%E7%AA%A5%E6%8E%A2%20Auto%20Layout/"/>
    <id>https://qiancaox.github.io/2019/03/28/从 WWDC 2018 220 Session 窥探 Auto Layout/</id>
    <published>2019-03-28T00:39:47.312Z</published>
    <updated>2019-03-28T01:08:12.787Z</updated>
    
    <content type="html"><![CDATA[<p>苹果公司早在 iOS 6 系统中就引入了 Auto Layout ，到目前为止，开发人员进行界面布局大致可以分为两类： Frame 、 Auto Layout 。使用 Frame 进行布局的开发者认为，这种方式更精确，并且性能优良，然而该方式过于原始，一方面在界面维护性差（杠精可能不这么觉得），另一方面在多屏幕适配上让人头疼。使用 Auto Layout 的开发者则认为，该方式在屏幕适配上占尽优势，在加入 了Interface Builder 后更是将“所见即所得”体现得淋漓尽致，但是最终形成视图显示时任然还是落实到 origin 和 size 上，从而中间会多出大量的根据约束、优先级等计算位置和大小的操作，一定程度上降低了性能，而且使用不当还极易造成崩溃。</p><a id="more"></a><p>在 <a href="https://developer.apple.com/videos/play/wwdc2018/220" target="_blank" rel="noopener">High Performance Auto Layout</a> 中介绍说：苹果公司在 iOS 12 中大幅提高了Auto Layout的性能，使滑动达到了满帧。为了更清楚解释 Auto Layout ，我们将从以下几点进行探讨：<a href="#运行过程">运行过程</a> 、<a href="#自动布局的性能问题">自动布局的性能问题</a>、<a href="#自动布局的方案">自动布局的方案</a></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>Auto Layout 布局系统不仅仅是实现了 <a href="https://en.wikipedia.org/wiki/Cassowary_(software" target="_blank" rel="noopener">Cassowary</a>) 算法来解决用户界面中哪些相等和不等的关系，引入了“约束”的概念来抽象界面关系。它还是一套完整的布局引擎系统，用来统一管理布局的创建、更新和销毁，它主导了整个界面的布局。</p><p><strong>首先</strong>，来看看自动布局的渲染过程。</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-14eb0502b89e9ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="渲染循环"></p><p>苹果将一个渲染循环分为了3个步骤：更新约束、布局和显示：</p><ol><li>所有需要的视图会根据层级关系从顶至低依次调用<code>updateConstraints</code>来更新约束；</li><li>接着，每个视图都会g根据层级关系沿着从低至顶的顺序依次执行<code>layoutSubviews</code>来进行布局；</li><li>最终，获取到布局信息后，视图和布局一样的执行方式调用<code>drawRect</code>进行绘制，从而将内容显示在用户的屏幕上。</li></ol><p><strong>于是</strong>，基于此流程，苹果开放了一套 API 给开发者使用，目的就是避免大量的重复工作，导致性能的损失：</p><ol><li><code>setNeedsUpdateConstraints</code>，将 view 标记为需要更新约束，并在稍后触发<code>updateConstraitsIfNeed</code>;</li><li><code>updateConstraitsIfNeeded</code>，系统自动调用该方法。但是只有被第1点标记了的 view 才会调用<code>updateConstraints</code>。该方法，开发者可以手动调用，但不需要重写。</li><li><code>updateConstraints</code>，更新约束的方法。</li><li><code>setNeedsLayout</code>，将 view 标记为需要重新布局，并在稍后自动触发<code>layoutIfNeeded</code>。当 view 的布局发生改变时，也会自动调用。</li><li><code>layoutIfNeeded</code>，系统自动调用该方法。同样，只有被第4点标记的 view 才会调用<code>layoutSubviews</code>。该方法，开发者可以手动调用，但也不需要重写。</li><li><code>layoutSubViews</code>，不能手动调用。</li><li><code>setNeedsDisplay</code>，将视图标记为需要重新绘制，并且触发绘制循环执行<code>drawRect</code>。</li><li><code>drawRect</code>，视图的绘制，不能手动调用。</li></ol><p>现在我们已经知道了 view 根据 Auto Layout 的绘制流程了，并且对苹果提供的 API 有了更为清晰的理解。</p><p><strong>最后</strong>，我们再来聊聊布局引擎（以下简称：Engine）在渲染过程中起到的作用：</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-6fdf087912e4eac2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Auto Layout Engine"></p><p>在自动布局框架中，布局的计算核心是 Engine ，换句话说，我们从添加的约束到获取到 view 的大小和位置信息都是由 Engine 进行计算的。我们说 Auto Layout 实现了 Cassowary 算法，主导了界面的布局，更精确的说是 Engine 来完成。</p><p>当然，光从上图很难看出 Engine 在渲染过程中起到的作用，我们结合 WWDC 进行理解。下面是一段原话：</p><blockquote><p>When the constraint is added what will happen is that we make an equation, which corresponds to the constraints, and we add that equation to the engine. The last object to understand in the diagram is that the equation is in terms of variables where a variable is like, you know, if I hand you an equation and I say solve for X, X is a variable. The things that we need to solve for in this case is the frame data of a view. So there will be four variables for every view, which is the min X, the min Y, the width, and the height.</p></blockquote><p>当我们给 view 添加约束（以下称：<code>NSLayoutConstraint</code>）时， Cocoa 会根据 <code>NSLayoutConstraint</code> 创建一个 Equation 的等式添加到 Engine 中，Engine 拿到等式后，依据 Cassowary 算法对 <code>NSLayoutConstraint</code> 中约定的变量（以下称：Variable）进行求解。求得结果后 view 通过 <code>layoutSubviews</code> 将 Engine 中的 Frame 拷贝出来，以供显示绘制使用。我们来看看代码是如何转化为 Equation 的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[NSLayoutConstraint constraintWithItem:view1</span><br><span class="line">                             attribute:NSLayoutAttributeLeft</span><br><span class="line">                             relatedBy:NSLayoutRelationEqual</span><br><span class="line">                                toItem:view2</span><br><span class="line">                             attribute:NSLayoutAttributeLeft</span><br><span class="line">                            multiplier:1</span><br><span class="line">                              constant:10]</span><br></pre></td></tr></table></figure><p>Equation =&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view1.left = view2.left * 1 + 10</span><br></pre></td></tr></table></figure><p>其中 view1.left 就是 <code>NSLayoutConstraint</code> 设置的 Variable ，需要 Engine 进行求解。</p><p>经过这样的理解，我将我的理解绘制成这样一幅简图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-b33d65a2096577ef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="how_engine_works"></p><p>上图中，我将 Engine 的工作这样理解：每个 view 在显示自己之前即得到布局信息之前， Engine 会将视图、约束、优先级和固定大小通过计算转换成最终的 Frame ，在 Engine 中，每当约束发生变化就会触发名叫：Deffered Layout Pass 的容错处理，当这些工作完成后，视图的绘制也会随之一并完成。为了继续监听约束变化，渲染循环（ps：其实这里渲染循环和运行循环是否是同一个东西，查了很多资料也没说个所以然，但是不影响对 Auto Layout 的理解。所以先暂时叫 Application Run Loop 统一名称。）又进入监听约束变化的状态，等待下次响应。当监听到约束变化后，再次执行下一轮循环。</p><p>这里有相关的参考链接：</p><ol><li><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ModifyingConstraints.html#//apple_ref/doc/uid/TP40010853-CH29-SW1" target="_blank" rel="noopener">Changing Constraints</a></li></ol><h2 id="自动布局的性能问题"><a href="#自动布局的性能问题" class="headerlink" title="自动布局的性能问题"></a>自动布局的性能问题</h2><p>上面我们对 Auto Layout 的运行过程进行了探讨。不难看出相对于 Frame 布局而言， Auto Layout 多出了对约束的更新、计算等操作，肯定会对效率产生一定的影响。然而这些影响如果在一次 Display 所允许的时间范围之内完成（60次/s），那么无论对开发者还是用户而言，都是可以接受的。在这章，我们一起来探讨影响 Auto Layout 性能的因素，从根儿上去理解这些问题，对我们将来开发工程中的取舍会有一定的帮助。</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-c57986cae44baac1.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="苹果官方数据"></p><p>上图是来 <a href="https://developer.apple.com/videos/play/wwdc2018/202/" target="_blank" rel="noopener">What’s New in Cocoa Touch</a> 数据，从上图可以看出，无论是嵌套还是非嵌套的视图层级关系而言，在 iOS 12 优化了 Auto Layout 之后，基本上和手动布局一致，都不会因为视图数量或嵌套层数的增加而导致性能的损耗成指数上升。那么导致优化前，性能成指数损耗的锅就应该由 Cassowary 来背吗？</p><blockquote><p>Cassowary is an incremental constraint solving toolkit that efficiently solves systems of linear equalities and inequalities.</p></blockquote><p>就 Cassowary 算法本身而言，是1997年就被发表并被称作高效的线性方程求解的算法，解决的是界面的线性规划问题，而线性规划问题的解法是单纯型法–<a href="https://en.wikipedia.org/wiki/Simplex" target="_blank" rel="noopener">Simplex</a>。单从 Simplex 算法看，大多数情况下是没有呈指数时间复杂度的。而 Cassowary 是在 Simplex 的基础上，为解决用户界面实践中的应用和改进算法，最重要的是提出了“增量”的概念。从这个维度上来看， Cassowary 不能背这口黑锅。</p><p>那么，如果 Cassowary 算法本身是没有问题的话，那就只可能是 iOS 12 之前在实现算法时，并没有体现出增量的概念。</p><p><img src="https://upload-images.jianshu.io/upload_images/1858049-5202337cd558eb51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="how_system_getting_size_from_engine"></p><p>在 WWDC 2018 220 Session 中提到，系统从 Engine 中获取 view 的大小可分为以下几步：</p><ol><li>创建一个 Engine 对象；</li><li>约束被添加到 Engine 中；</li><li>Engine 计算出所有的布局信息；</li><li>view 从 Engine 中拷贝出布局信息；</li><li>Engine 对象呗销毁。</li></ol><p>咋眼一看似乎没有什么问题，但是如果每次细微的更新约束都需要从0开始，新的计算引擎对象都要重新计算，当约束变关系变多时，最终会导致计算量的指数上升。</p><p>显然苹果早就注意到这个问题，在 iOS 12 中找到了并实现了解法。当然，性能是否真的如视频所说？这里有一篇文章，对 Auto Layout 进行了比较深入的测试：<a href="http://www.cocoachina.com/ios/20181106/25391.html" target="_blank" rel="noopener">点击查看</a>。</p><p>综上所述，尽管苹果一直在对 Auto Layout 进行优化升级，但目前为止，任然不如 Frame 布局来的直接、有效，然而这只是在相对极端的情况下才会出现，通常我们遇到的开发需求中是不会出现这种情况的。最终我们可以粗暴的认为： <strong>Auto Layout 具有了和手写布局几乎一致的高性能。</strong></p><h2 id="自动布局的方案"><a href="#自动布局的方案" class="headerlink" title="自动布局的方案"></a>自动布局的方案</h2><p>除了上面探讨的 Auto Layout 性能问题之外， Auto Layout 框架的易用性也是影响其使用的关键因素之一。苹果公司自然比我们更清楚这一点的重要性。所以，后来又提供 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html" target="_blank" rel="noopener">VFL</a> 这种 DSL 语言来简化 Auto Layout 的写法。再到后来，苹果紧随前端响应式布局– Flexbox 的思路，基于 Auto Layout 封装了 <code>UIStackView</code> 来提高响应式布局的开发效率。当然，这里我们不去着重探讨上述的布局方案，而是简单阐述以下几种 Auto Layout 方案的优缺点，以供大家选择：</p><ol><li><code>NSLayoutConstraint</code> 实现 Auto Layout</li></ol><p>上述我们提到了苹果使用 <code>NSLayoutConstraint</code> 来体现了 Cassowary 的约束的概念，并且苹果在 Auto Layout 框架中也只提供了它所对应的一套 API 供开发者使用，也就是说任何基于自动布局技术的其他方案都必然会通过 <code>NSLayoutConstraint</code> 来实现。</p><p>从上面的代码中，可以看出 <code>NSLayoutConstraint</code> 的可阅读性还是很好的，然而对开发过程中，多如牛毛的约束，显然这种方式是不可取得，太影响开发效率了。</p><ol start="2"><li>苹果自家的可视化编辑方案：Interface Builder</li></ol><p>我认为 Interface Builder 是一个革命性的突破。在没有它之前，我们的所有控件都必须通过代码初始化，设置 frame ，设置各种属性，然后 <code>addSubview</code> 到父视图上。这部分工作重复且毫无意义，直到 IB 的出现，它让 iOS 开发工程能够更容易的构建 App 的视图，并且更直观的进行视图编辑，只是简单的通过点击选择、拖拽等操作就可完成，最后通过 <code>IBOutlet</code> 将 IB 中的控件连接到代码中，供开发者直接使用。更多的时间都投入到业务开发中去，大大的提高了工程师的开发效率。（ps：我之前注意到，相同的需求，相同的迭代周期，相同的界面，Android由3个开发同时进行，iOS由2个开发同时开发，最终iOS完成迭代开发的时间早于Android2天，并且从高保真的还原度上而言也是得到了UI同事的赞扬的！）</p><p>难道 IB 真的就这么完美，找不出缺点吗？</p><p>答案是否定的。 IB 在有如此高效且易用的有点下，缺点也是十分明显：</p><ul><li>IB 本质上也是一个 XML 文件，最终呈现成 view 时还是会转化成代码来完成，从而 IB 的执行效率低于手写代码；</li><li>在多团队开发中容易造成错误；</li><li>不利于代码的封装和工程架构的组织等；</li><li>学习成本相对较高。</li></ul><ol start="3"><li><code>Masonry</code> 三方框架</li></ol><p>你或许没有使用过 IB 进行界面开发，但是我相信 <code>Masonry</code> 你一定用过。它是基于 Auto Layout 的链式封装，不仅简化了 <code>NSLayoutConstraint</code> 带来繁杂的工作量，还更加清晰明了的解释了视图之间的约束关系。目前从我所经历的需求池看来， <code>Masonry</code> 都能够完成。毕竟是基于“老祖宗”的。虽然，时至今日，开发者也发现了很多它的问题，但这都是后话了，也不属于我们需要在这里探讨的话题了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章是我在观看了 WWDC 2018 220和202 之后对 Auto Layout 一些感悟或者理解。我们从原理上探讨了自动布局技术的运行过程和自动布局的性能问题，并简单的提到了苹果在布局引擎中利用 Cassowary 算法进行线性规划问题的求解，对以后开发过程中遇到的问题能有更深层次的解释，自然也能更容易解决这些问题。又简单的总结了3中自动布局方案，并分别简述了各自的优缺点，希望能够为技术选型时提供一些参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果公司早在 iOS 6 系统中就引入了 Auto Layout ，到目前为止，开发人员进行界面布局大致可以分为两类： Frame 、 Auto Layout 。使用 Frame 进行布局的开发者认为，这种方式更精确，并且性能优良，然而该方式过于原始，一方面在界面维护性差（杠精可能不这么觉得），另一方面在多屏幕适配上让人头疼。使用 Auto Layout 的开发者则认为，该方式在屏幕适配上占尽优势，在加入 了Interface Builder 后更是将“所见即所得”体现得淋漓尽致，但是最终形成视图显示时任然还是落实到 origin 和 size 上，从而中间会多出大量的根据约束、优先级等计算位置和大小的操作，一定程度上降低了性能，而且使用不当还极易造成崩溃。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发笔记" scheme="https://qiancaox.github.io/categories/iOS-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
